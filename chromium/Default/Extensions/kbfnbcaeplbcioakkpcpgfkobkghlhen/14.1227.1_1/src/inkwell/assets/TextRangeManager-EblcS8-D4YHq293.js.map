{"version":3,"file":"TextRangeManager-EblcS8-D4YHq293.js","sources":["../../../util-text/dist/TextRangeFns-CQvsgY.mjs","../../../util-bitset/dist/index.mjs","../../../util-text/dist/IntervalTree-BLlq9u.mjs","../../../util-text/dist/TextRangeManager-EblcS8.mjs"],"sourcesContent":["/**\n * Computes the bounding range of the provided text ranges.\n * @public\n */\nfunction union(a, ...ranges) {\n    return {\n        start: Math.min(a.start, ...ranges.map(r => r.start)),\n        end: Math.max(a.end, ...ranges.map(r => r.end)),\n    };\n}\n/**\n * Check if two text ranges intersect.\n * @public\n * @param a - the first range\n * @param b - the second range\n * @returns `true` if the ranges intersect\n */\nfunction intersect(a, b) {\n    return b.start > a.end || b.end < a.start ? false : true;\n}\n/**\n * Computes the difference A - B between two text ranges A and B.\n * @public\n * @param a - the first range\n * @param b - the second range\n * @returns the difference a - b\n */\nfunction difference(a, b) {\n    if (a.start <= b.start) {\n        return { start: a.start, end: Math.min(a.end, b.start) };\n    }\n    else if (a.end > b.end) {\n        return { end: a.end, start: Math.max(b.end, a.start) };\n    }\n    else {\n        // a.start > b.start && a.end < b.end\n        return { start: a.start, end: a.start };\n    }\n}\n/**\n * Widens the text range by the specified amount.\n * @public\n * @param a - the text range\n * @param amount - the amount to widen\n * @param minMax - the min and max values\n */\nfunction widen(a, amount, minMax = [0, Number.MAX_SAFE_INTEGER]) {\n    return { start: Math.max(a.start - amount, minMax[0]), end: Math.min(a.end + amount, minMax[1]) };\n}\n/**\n * Returns `true` if the text range is collapsed.\n */\nfunction isCollapsed(range) {\n    return range.start === range.end;\n}\n/**\n * Converts the text range to a string.\n * @public\n * @param range - the text range\n * @returns String representation\n */\nfunction toString(range) {\n    return `[${range.start}, ${range.end})`;\n}\n\nexport { difference, intersect, isCollapsed, toString, union, widen };\n//# sourceMappingURL=TextRangeFns-CQvsgY.mjs.map\n","/**\n * Utilities for manipulating bitsets\n * @packageDocumentation\n */\n/**\n * Get the bit at the given index\n * @returns `true` if the bit at the given position is set, `false` otherwise\n * @public\n */\nfunction getBit(flags, bitIndex) {\n    return (flags & (1 << bitIndex)) !== 0;\n}\n/**\n * Set the bit at the given position\n * @returns The updated BitFlags\n * @public\n */\nfunction setBit(flags, bitIndex) {\n    return (flags | (1 << bitIndex));\n}\n/**\n * Clear the bit at the given position\n * @returns The updated BitFlags\n * @public\n */\nfunction clearBit(flags, bitIndex) {\n    return (flags & ~(1 << bitIndex));\n}\n/**\n * Toggle the bit at the given position\n * @returns The updated BitFlags\n * @public\n */\nfunction toggleBit(flags, bitIndex) {\n    return (flags ^ (1 << bitIndex));\n}\n\nexport { clearBit, getBit, setBit, toggleBit };\n//# sourceMappingURL=index.mjs.map\n","import { getBit, setBit, clearBit } from '@grammarly/util-bitset';\nimport { isRetainOp, isInsertOp, getOpLength, isDeleteOp } from '@grammarly/util-delta';\nimport { logger } from '@grammarly/util-logging';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n * This code was adapted from VSCode's interval tree implementation.\n * https://github.com/microsoft/vscode/blob/main/src/vs/editor/common/model/intervalTree.ts\n *--------------------------------------------------------------------------------------------*/\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n/** @internal */\nconst NodeColor = {\n    Black: 0,\n    Red: 1\n};\n/**\n * Determines how the range is edited when edits intersect or are adjacent to the range.\n */\nconst NodeEditBehavior = {\n    Resize: 0,\n    Collapse: 1\n};\nconst ColorBit = 0;\nconst IsVisitedBit = 1;\nconst EditBehaviorBit = 2;\n/**\n * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node)\n * the deltas for nodes can grow and shrink dramatically. It has been observed in practice that unless\n * the deltas are corrected integer overflow will occur.\n *\n * The integer overflow occurs when 53 bits are used in the numbers but we will try to avoid it as\n * a node's offset gets below a negative 30 bits number.\n *\n * MIN SMI (SMall Integer) as defined in v8.\n * one bit is lost for boxing/unboxing flag.\n * one bit is lost for sign flag.\n * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n */\nconst MIN_SAFE_DELTA = /* @__PURE__ */ (() => -(1 << 30))();\n/**\n * MAX SMI (SMall Integer) as defined in v8.\n * one bit is lost for boxing/unboxing flag.\n * one bit is lost for sign flag.\n * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n */\nconst MAX_SAFE_DELTA = /* @__PURE__ */ (() => 1 << 30)();\n/** @internal */\nfunction getNodeColor(node) {\n    return getBit(node.metadata, ColorBit) === true ? NodeColor.Red : NodeColor.Black;\n}\nfunction setNodeColor(node, color) {\n    if (color) {\n        node.metadata = setBit(node.metadata, ColorBit);\n    }\n    else {\n        node.metadata = clearBit(node.metadata, ColorBit);\n    }\n}\nfunction getNodeIsVisited(node) {\n    return getBit(node.metadata, IsVisitedBit);\n}\nfunction setNodeIsVisited(node, value) {\n    if (value) {\n        node.metadata = setBit(node.metadata, IsVisitedBit);\n    }\n    else {\n        node.metadata = clearBit(node.metadata, IsVisitedBit);\n    }\n}\nfunction getNodeEditBehavior(node) {\n    return getBit(node.metadata, EditBehaviorBit) === true\n        ? NodeEditBehavior.Collapse\n        : NodeEditBehavior.Resize;\n}\nfunction setNodeEditBehavior(node, editBehavior) {\n    if (editBehavior) {\n        node.metadata = setBit(node.metadata, EditBehaviorBit);\n    }\n    else {\n        node.metadata = clearBit(node.metadata, EditBehaviorBit);\n    }\n}\nclass IntervalNode {\n    /**\n     * contains binary encoded information for color, visited and nodeBehavior.\n     */\n    metadata;\n    parent;\n    left;\n    right;\n    start;\n    end;\n    offset;\n    // Stores the maximum end of this node and its children.\n    maxEnd;\n    // The following values are calculated on demand when a range is resolved.\n    // This is done when querying the interval tree for intersections or when doing an in-order traversal.\n    cachedRevision;\n    cachedAbsoluteStart;\n    cachedAbsoluteEnd;\n    // A callback that is invoked before a node gets affected by a text change.\n    // This is not called if the node does not intersect, or is not adjacent to the text change.\n    onBeforeEditOperation;\n    constructor(start, end, behavior, onBeforeEditOperation) {\n        this.metadata = 0;\n        this.onBeforeEditOperation = onBeforeEditOperation;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, NodeColor.Red);\n        this.start = start;\n        this.end = end;\n        this.offset = 0;\n        this.maxEnd = end;\n        setNodeEditBehavior(this, behavior);\n        this.cachedRevision = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        setNodeIsVisited(this, false);\n    }\n    /** @internal */\n    reset(revision, start, end) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedRevision = revision;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n    }\n    /** @internal */\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedRevision) {\n        this.cachedRevision = cachedRevision;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    /** @internal */\n    detach() {\n        this.parent = IntervalNode.SENTINEL;\n        this.left = IntervalNode.SENTINEL;\n        this.right = IntervalNode.SENTINEL;\n    }\n    static SENTINEL = /* @__PURE__ */ IntervalNode.#createSentinel();\n    static #createSentinel() {\n        const sentinel = new IntervalNode(0, 0, NodeEditBehavior.Resize);\n        sentinel.parent = sentinel;\n        sentinel.left = sentinel;\n        sentinel.right = sentinel;\n        setNodeColor(sentinel, NodeColor.Black);\n        return sentinel;\n    }\n}\n/**\n * An interval tree implementation to store intervals ordered by start and allow for efficient\n * insertion/deletion and interval search.\n */\nclass IntervalTree {\n    root;\n    requestNormalizeOffsets;\n    revision;\n    constructor(revision = 0) {\n        this.root = IntervalNode.SENTINEL;\n        this.revision = revision;\n        this.requestNormalizeOffsets = false;\n    }\n    /**\n     * Get all nodes intersecting the given interval\n     * @param start - The start of the interval\n     * @param end - The end of the interval\n     * @returns A list of intersecting nodes (including adjacent intervals)\n     * @remarks The nodes that are returned will have their revision/absoluteStart/absoluteEnd updated.\n     */\n    intervalSearch(start, end) {\n        if (this.root === IntervalNode.SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, this.revision);\n    }\n    /**\n     * Get all the nodes ordered by interval start\n     * @returns A list of ordered and resolved nodes\n     * @remarks The nodes that are returned will have their revision/absoluteStart/absoluteEnd updated.\n     */\n    getAllInOrder() {\n        if (this.root === IntervalNode.SENTINEL) {\n            return [];\n        }\n        return getAllInOrder(this, this.revision);\n    }\n    /**\n     * Insert a node in the tree while preserving the order.\n     * @param node - The node to insert\n     */\n    insert(node) {\n        node.cachedRevision = this.revision;\n        rbTreeInsert(this, node);\n        this.normalizeOffsetsIfNeeded();\n    }\n    /**\n     * Remove a node from the tree.\n     * @param node - The node to delete\n     */\n    delete(node) {\n        rbTreeDelete(this, node);\n        this.normalizeOffsetsIfNeeded();\n    }\n    /**\n     * If a node's cached revision doesn't match the tree revision, then\n     * calculate its absolute start and end by aggregating the parent deltas and cache\n     * the absolute offsets and the revision in the node.\n     * @param node - The node to resolve\n     * @param revision - The revision to use when updating nodes' revision and offsets\n     */\n    resolveNodeIfNeeded(node) {\n        if (node.cachedRevision !== this.revision) {\n            const initialNode = node;\n            let offset = 0;\n            while (node !== this.root) {\n                if (node === IntervalNode.SENTINEL) {\n                    return logger.warn('IntervalTree: Cannot resolve detached node');\n                }\n                if (node === node.parent.right) {\n                    offset += node.parent.offset;\n                }\n                node = node.parent;\n            }\n            const nodeStart = initialNode.start + offset;\n            const nodeEnd = initialNode.end + offset;\n            initialNode.setCachedOffsets(nodeStart, nodeEnd, this.revision);\n        }\n    }\n    /**\n     * Apply an edit to the interval tree and updates nodes.\n     * @param change - text change\n     * @returns A list of nodes that were collapsed or resized (the change intersected or was adjacent to these nodes)\n     */\n    acceptEdit(change, revision) {\n        const affectedNodes = new Set();\n        let pos = 0;\n        change.ops.forEach(op => {\n            if (isRetainOp(op)) {\n                pos += op.retain;\n            }\n            else if (isInsertOp(op)) {\n                const nodes = this.#acceptInsert(pos, op);\n                for (const node of nodes) {\n                    affectedNodes.add(node);\n                }\n                pos += getOpLength(op);\n            }\n            else if (isDeleteOp(op)) {\n                const nodes = this.#acceptDelete(pos, op);\n                for (const node of nodes) {\n                    affectedNodes.add(node);\n                }\n            }\n        });\n        this.revision = revision;\n        for (const node of affectedNodes) {\n            this.resolveNodeIfNeeded(node);\n        }\n        return [...affectedNodes];\n    }\n    #acceptInsert(offset, op) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        const text = typeof op.insert === 'string'\n            ? op.insert\n            : // we treat embeds as punctuation so they won't affect word boundaries\n                // when inserted at the edge of a range\n                ' ';\n        // (1) collect all nodes that are intersecting this insert position as nodes of interest\n        const nodesOfInterest = searchNodesInEditRange(this, offset, offset);\n        for (const node of nodesOfInterest) {\n            node.onBeforeEditOperation?.(offset, op);\n        }\n        // (2) remove all nodes that are intersecting this insert position\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this.normalizeOffsetsIfNeeded();\n        // (3) shift all tree nodes except the nodes of interest\n        shiftNodesAfterEdit(this, offset, offset, text.length);\n        this.normalizeOffsetsIfNeeded();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptInsert(node, offset, text);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this.normalizeOffsetsIfNeeded();\n        return nodesOfInterest;\n    }\n    #acceptDelete(offset, op) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        const deletionLength = op.delete;\n        // (1) collect all nodes that are intersecting the deletion as nodes of interest\n        const nodesOfInterest = searchNodesInEditRange(this, offset, offset + deletionLength);\n        for (const node of nodesOfInterest) {\n            node.onBeforeEditOperation?.(offset, op);\n        }\n        // (2) remove all nodes that are intersecting the deletion\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this.normalizeOffsetsIfNeeded();\n        // (3) shift all tree nodes except the nodes of interest\n        shiftNodesAfterEdit(this, offset, offset + deletionLength, 0);\n        this.normalizeOffsetsIfNeeded();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptDelete(node, offset, deletionLength);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this.normalizeOffsetsIfNeeded();\n        return nodesOfInterest;\n    }\n    normalizeOffsetsIfNeeded() {\n        if (!this.requestNormalizeOffsets) {\n            return;\n        }\n        this.requestNormalizeOffsets = false;\n        normalizeOffset(this);\n    }\n}\n//#region Offset Normalization\nfunction normalizeOffset(T) {\n    let node = T.root;\n    let offset = 0;\n    while (node !== IntervalNode.SENTINEL) {\n        if (node.left !== IntervalNode.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== IntervalNode.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            offset += node.offset;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = offset + node.start;\n        node.end = offset + node.end;\n        node.offset = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            offset -= node.parent.offset;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Editing\nfunction isWordBreakCharacter(char) {\n    const c = char.charCodeAt(0);\n    return (c < 48 || // non-printable chars, space, !\"#$%&'()*+,-./\n        c === 58 || // :\n        c === 59 || // ;\n        c === 63 || // ?\n        c === 8220 || // “\n        c === 8221 || // ”\n        c === 8216 || // ‘\n        c === 8217 // ’\n    );\n}\nfunction nodeAcceptInsert(node, start, text) {\n    const editBehavior = getNodeEditBehavior(node);\n    if (start < node.start || start > node.end || text.length === 0) {\n        return;\n    }\n    // Collapse or shift the range when text is inserted at the left edge\n    if (start === node.start) {\n        const insertIsWordBreak = isWordBreakCharacter(text.charAt(text.length - 1));\n        // Collapse if the insert is a not word break (changes the word boundary)\n        if (editBehavior === NodeEditBehavior.Collapse && !insertIsWordBreak) {\n            // Collapse the range just after the insert\n            node.start = node.end = start + text.length;\n        }\n        // Shift the range to the right\n        else {\n            node.start += text.length;\n            node.end += text.length;\n        }\n    }\n    // Collapse or shift the range when text is inserted at the right edge\n    else if (start === node.end) {\n        const insertIsWordBreak = isWordBreakCharacter(text.charAt(0));\n        // Collapse if the insert is a not word break (changes the word boundary)\n        if (editBehavior === NodeEditBehavior.Collapse && !insertIsWordBreak) {\n            node.end = node.start;\n        }\n    }\n    // Resize the range when text is inserted in the middle\n    else {\n        if (editBehavior === NodeEditBehavior.Resize) {\n            node.end += text.length;\n        }\n        else {\n            node.end = node.start;\n        }\n    }\n}\nfunction nodeAcceptDelete(node, start, deletionLength) {\n    const editBehavior = getNodeEditBehavior(node);\n    if (start + deletionLength < node.start || start > node.end || deletionLength === 0) {\n        return;\n    }\n    // Deletion overlaps node entirely (collapse)\n    if (start <= node.start && node.end <= start + deletionLength) {\n        node.end = node.start;\n    }\n    // Deletion overlaps with node start (clip start or collapse)\n    else if (start <= node.start && start + deletionLength > node.start) {\n        if (editBehavior === NodeEditBehavior.Collapse) {\n            node.end = node.start = start;\n        }\n        else {\n            const trimStart = start + deletionLength - node.start;\n            const newLength = node.end - node.start - trimStart;\n            node.end = start + newLength;\n            node.start = start;\n        }\n    }\n    // Deletion overlaps with node end (clip end or collapse)\n    else if (start <= node.end && start + deletionLength > node.end) {\n        if (editBehavior === NodeEditBehavior.Collapse) {\n            node.end = node.start;\n        }\n        else {\n            node.end = start;\n        }\n    }\n    // Deletion within node (resize or collapse)\n    else if (start >= node.start && start + deletionLength <= node.end) {\n        if (editBehavior === NodeEditBehavior.Collapse) {\n            node.end = node.start;\n        }\n        else {\n            node.end -= deletionLength;\n        }\n    }\n    else {\n        if (editBehavior === NodeEditBehavior.Collapse) {\n            node.end = node.start = start;\n        }\n        else {\n            node.end -= deletionLength;\n            node.start -= deletionLength;\n        }\n    }\n}\nfunction searchNodesInEditRange(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let offset = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== IntervalNode.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                offset -= node.parent.offset;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = offset + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== IntervalNode.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = offset + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = offset + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== IntervalNode.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            offset += node.offset;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction shiftNodesAfterEdit(T, start, end, newTextLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let offset = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = newTextLength - (end - start);\n    while (node !== IntervalNode.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                offset -= node.parent.offset;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = offset + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== IntervalNode.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = offset + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.offset += editDelta;\n            if (node.offset < MIN_SAFE_DELTA || node.offset > MAX_SAFE_DELTA) {\n                T.requestNormalizeOffsets = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== IntervalNode.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            offset += node.offset;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction getAllInOrder(T, cachedRevision) {\n    let node = T.root;\n    let offset = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const results = [];\n    while (node !== IntervalNode.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                offset -= node.parent.offset;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== IntervalNode.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = offset + node.start;\n        nodeEnd = offset + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedRevision);\n        results.push(node);\n        setNodeIsVisited(node, true);\n        if (node.right !== IntervalNode.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            offset += node.offset;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return results;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, cachedRevision) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let offset = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const results = [];\n    while (node !== IntervalNode.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                offset -= node.parent.offset;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = offset + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== IntervalNode.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = offset + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = offset + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedRevision);\n            results.push(node);\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== IntervalNode.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            offset += node.offset;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return results;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === IntervalNode.SENTINEL) {\n        newNode.parent = IntervalNode.SENTINEL;\n        newNode.left = IntervalNode.SENTINEL;\n        newNode.right = IntervalNode.SENTINEL;\n        setNodeColor(newNode, NodeColor.Black);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === NodeColor.Red) {\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(y, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === NodeColor.Red) {\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(y, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, NodeColor.Black);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let offset = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + offset, x.end + offset);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's offset\n            if (x.left === IntervalNode.SENTINEL) {\n                z.start -= offset;\n                z.end -= offset;\n                z.maxEnd -= offset;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's offset\n            if (x.right === IntervalNode.SENTINEL) {\n                z.start -= offset + x.offset;\n                z.end -= offset + x.offset;\n                z.maxEnd -= offset + x.offset;\n                x.right = z;\n                break;\n            }\n            else {\n                offset += x.offset;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = IntervalNode.SENTINEL;\n    z.right = IntervalNode.SENTINEL;\n    setNodeColor(z, NodeColor.Red);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === IntervalNode.SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's offset is no longer influenced by z's offset\n        x.offset += z.offset;\n        if (x.offset < MIN_SAFE_DELTA || x.offset > MAX_SAFE_DELTA) {\n            T.requestNormalizeOffsets = true;\n        }\n        x.start += z.offset;\n        x.end += z.offset;\n    }\n    else if (z.right === IntervalNode.SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's offset is no longer influenced by z's offset,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's offset in y, and adjust only x\n        x.start += y.offset;\n        x.end += y.offset;\n        x.offset += y.offset;\n        if (x.offset < MIN_SAFE_DELTA || x.offset > MAX_SAFE_DELTA) {\n            T.requestNormalizeOffsets = true;\n        }\n        y.start += z.offset;\n        y.end += z.offset;\n        y.offset = z.offset;\n        if (y.offset < MIN_SAFE_DELTA || y.offset > MAX_SAFE_DELTA) {\n            T.requestNormalizeOffsets = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, NodeColor.Black);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = IntervalNode.SENTINEL;\n        return;\n    }\n    const yWasRed = getNodeColor(y) === NodeColor.Red;\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== IntervalNode.SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== IntervalNode.SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === NodeColor.Red) {\n                setNodeColor(w, NodeColor.Black);\n                setNodeColor(x.parent, NodeColor.Red);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                setNodeColor(w, NodeColor.Red);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === NodeColor.Black) {\n                    setNodeColor(w.left, NodeColor.Black);\n                    setNodeColor(w, NodeColor.Red);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(w.right, NodeColor.Black);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === NodeColor.Red) {\n                setNodeColor(w, NodeColor.Black);\n                setNodeColor(x.parent, NodeColor.Red);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                setNodeColor(w, NodeColor.Red);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === NodeColor.Black) {\n                    setNodeColor(w.right, NodeColor.Black);\n                    setNodeColor(w, NodeColor.Red);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(w.left, NodeColor.Black);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, NodeColor.Black);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== IntervalNode.SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    IntervalNode.SENTINEL.parent = IntervalNode.SENTINEL;\n    IntervalNode.SENTINEL.offset = 0; // optional\n    IntervalNode.SENTINEL.start = 0; // optional\n    IntervalNode.SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.offset += x.offset; // y's offset is no longer influenced by x's offset\n    if (y.offset < MIN_SAFE_DELTA || y.offset > MAX_SAFE_DELTA) {\n        T.requestNormalizeOffsets = true;\n    }\n    y.start += x.offset;\n    y.end += x.offset;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== IntervalNode.SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === IntervalNode.SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.offset -= x.offset;\n    if (y.offset < MIN_SAFE_DELTA || y.offset > MAX_SAFE_DELTA) {\n        T.requestNormalizeOffsets = true;\n    }\n    y.start -= x.offset;\n    y.end -= x.offset;\n    y.left = x.right;\n    if (x.right !== IntervalNode.SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === IntervalNode.SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== IntervalNode.SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== IntervalNode.SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.offset;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nfunction recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== IntervalNode.SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\n/** @internal */\nfunction intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n\nexport { IntervalNode, IntervalTree, NodeColor, NodeEditBehavior, getNodeColor, intervalCompare };\n//# sourceMappingURL=IntervalTree-BLlq9u.mjs.map\n","import { CircularBuffer } from '@grammarly/util-array';\nimport { Delta, isRetainOp, getOpType, isInsertOp, getOpLength } from '@grammarly/util-delta';\nimport { UnreachableCaseError, CustomError } from '@grammarly/util-error';\nimport { isNonNullable, pipe } from '@grammarly/util-function';\nimport { isDev } from '@grammarly/util-is-dev';\nimport { map, filter, toArray } from '@grammarly/util-iterable';\nimport { logger } from '@grammarly/util-logging';\nimport { Result } from '@grammarly/util-result';\nimport { IdSequence } from '@grammarly/util-uuid';\nimport { IntervalTree, IntervalNode, NodeEditBehavior } from './IntervalTree-BLlq9u.mjs';\nimport { toString } from './TextRangeFns-CQvsgY.mjs';\nimport { TextRangeUpdateSemantics } from './TextRangeUpdateSemantics-D8MqPO.mjs';\nimport { create } from './TextRevisionFns-DnfI8a.mjs';\n\n/**\n * A manager responsible for keeping a collection of text ranges in sync with text changes.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextRangeManager {\n    #logger;\n    #liveRanges = new Map();\n    #intervalTree;\n    #idSequence = new IdSequence();\n    // TODO: Prune the queue when a text-change is released and CAPI sends a finished(all_checks_completed) message for the revision.\n    #history = new CircularBuffer({ capacity: 1000 });\n    constructor(options) {\n        this.#logger = logger.createLogger(options.label ?? 'TextRangeManager');\n        this.#intervalTree = new IntervalTree(options.initialTextRevision);\n    }\n    /** { @inheritdoc TextRangeManager.pushTextChange} */\n    pushTextChange({ change, revision, }) {\n        this.#history.push({ change: new Delta(change), revision });\n        const affectedRanges = this.#intervalTree\n            .acceptEdit(change, revision)\n            .map(node => this.#liveRanges.get(node))\n            .filter(isNonNullable);\n        // All ranges after the change are changed\n        const firstOp = change.ops[0];\n        const changeStart = firstOp && isRetainOp(firstOp) ? firstOp.retain : 0;\n        // We have to merge the affected ranges and changed ranges to make sure we don't omit ranges that were collapsed\n        // and may now be located before the change location\n        const getChangedRanges = () => concatAffectedAndChangedRanges(affectedRanges, pipe(this.#intervalTree.intervalSearch(changeStart, Number.MAX_SAFE_INTEGER), map(node => this.#liveRanges.get(node)), filter(isNonNullable)));\n        this.#logger.verbose('pushTextChange', {\n            change,\n            revision,\n            affectedRanges,\n        });\n        return {\n            affectedRanges,\n            getChangedRanges,\n        };\n    }\n    /** { @inheritdoc TextRangeManager.add} */\n    add(options) {\n        return pipe(this.#rebaseRangeOnLatestRevision(options, create(this.#intervalTree.revision)), Result.map(rebasedRange => {\n            const node = new IntervalNode(rebasedRange.start, rebasedRange.end, getNodeEditBehavior(options.updateSemantics), options.onBeforeEditOperation);\n            this.#intervalTree.insert(node);\n            const liveRange = new DefaultLiveTextRange({\n                id: options.id ?? this.#idSequence.next(),\n                node,\n                intervalTree: this.#intervalTree,\n                metadata: options.metadata,\n                onDispose: () => {\n                    this.#intervalTree.delete(node);\n                    this.#liveRanges.delete(node);\n                },\n            });\n            this.#liveRanges.set(node, liveRange);\n            return liveRange;\n        }));\n    }\n    /** { @inheritdoc TextRangeManager.getIntersecting} */\n    getIntersecting(range) {\n        return pipe(this.#intervalTree.intervalSearch(range.start, range.end), map(node => this.#liveRanges.get(node)), filter(isNonNullable), toArray);\n    }\n    /** { @inheritdoc TextRangeManager.getAllInOrder} */\n    getAllInOrder() {\n        return pipe(this.#intervalTree.getAllInOrder(), map(node => this.#liveRanges.get(node)), filter(isNonNullable), toArray);\n    }\n    [Symbol.dispose]() {\n        // We don't dispose live ranges, as this would just remove nodes from the interval tree\n        // which is useless work that will trigger rebalancing.\n        this.#liveRanges.clear();\n    }\n    #rebaseRangeOnLatestRevision(textRangeAddOptions, expectedRevision) {\n        const { range, revision, updateSemantics } = textRangeAddOptions;\n        if (revision === this.#intervalTree.revision) {\n            return Result.success(range);\n        }\n        const deltas = this.#getChangesSince(revision);\n        const start = deltas.reduce((pos, delta) => delta.transformPosition(pos), range.start);\n        const end = deltas.reduce((pos, delta) => delta.transformPosition(pos, true), range.end);\n        if (end - start <= 0 ||\n            (end - start !== range.end - range.start &&\n                updateSemantics === TextRangeUpdateSemantics.Collapse)) {\n            this.#logger.warn(`Collapsed range ${toString(range)} after rebasing from ${revision} to ${this.#intervalTree.revision}. New range: ${toString({ start, end })}`);\n            this.#logger.verbose('Changes:', deltas);\n            return Result.failure(new RangeRebasingError({\n                fromRevision: textRangeAddOptions.revision,\n                toRevision: expectedRevision,\n                range: textRangeAddOptions.range,\n                rebasedRange: { start, end },\n                deltas,\n            }));\n        }\n        if (isDev) {\n            this.#logger.verbose(`Rebased range ${toString(range)} from ${revision} to ${this.#intervalTree.revision}: ${toString({ start, end })}`);\n        }\n        return Result.success({ start, end });\n    }\n    #getChangesSince(revision) {\n        return pipe(this.#history, filter(change => change.revision > revision), map(change => change.change), toArray);\n    }\n}\n/**\n * Default implementation of LiveTextRange wrapping an IntervalNode\n * When start/end are accessed, we make sure to resolve the node first to update the cached values.\n * @internal\n */\nclass DefaultLiveTextRange {\n    #intervalNode;\n    #intervalTree;\n    #disposables = new DisposableStack();\n    id;\n    metadata;\n    constructor(options) {\n        this.id = options.id;\n        this.#intervalNode = options.node;\n        this.#intervalTree = options.intervalTree;\n        this.metadata = options.metadata;\n        this.#disposables.defer(options.onDispose);\n    }\n    get start() {\n        if (this.#disposables.disposed) {\n            logger.warn('Cannot access DefaultLiveTextRange.start after disposal');\n            return NaN;\n        }\n        // Update cached values if the node's revision doesn't match the tree revision\n        this.#intervalTree.resolveNodeIfNeeded(this.#intervalNode);\n        return this.#intervalNode.cachedAbsoluteStart;\n    }\n    get end() {\n        if (this.#disposables.disposed) {\n            logger.warn('Cannot access DefaultLiveTextRange.end after disposal');\n            return NaN;\n        }\n        // Update cached values if the node's revision doesn't match the tree revision\n        this.#intervalTree.resolveNodeIfNeeded(this.#intervalNode);\n        return this.#intervalNode.cachedAbsoluteEnd;\n    }\n    get revision() {\n        return create(this.#intervalTree.revision);\n    }\n    [Symbol.dispose]() {\n        this.#disposables.dispose();\n    }\n    toJSON() {\n        return {\n            start: this.start,\n            end: this.end,\n            revision: this.revision,\n            metadata: this.metadata,\n        };\n    }\n}\nfunction* concatAffectedAndChangedRanges(affectedRanges, changedRanges) {\n    const affectedRangesSet = new Set(affectedRanges);\n    for (const range of affectedRanges) {\n        yield range;\n    }\n    for (const range of changedRanges) {\n        if (affectedRangesSet.size > 0 && affectedRangesSet.has(range)) {\n            affectedRangesSet.delete(range);\n            continue;\n        }\n        yield range;\n    }\n}\nfunction getNodeEditBehavior(updateSemantics) {\n    if (updateSemantics === TextRangeUpdateSemantics.Resize) {\n        return NodeEditBehavior.Resize;\n    }\n    else if (updateSemantics === TextRangeUpdateSemantics.Collapse) {\n        return NodeEditBehavior.Collapse;\n    }\n    else {\n        throw new UnreachableCaseError(updateSemantics);\n    }\n}\nclass RangeRebasingError extends CustomError {\n    fromRevision;\n    toRevision;\n    deltas;\n    range;\n    rebasedRange;\n    constructor(details) {\n        super('Failed to rebase range');\n        this.fromRevision = details.fromRevision;\n        this.toRevision = details.toRevision;\n        this.deltas = details.deltas;\n        this.range = details.range;\n        this.rebasedRange = details.rebasedRange;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            fromRevision: this.fromRevision,\n            toRevision: this.toRevision,\n            range: this.range,\n            rebasedRange: this.rebasedRange,\n            deltas: this.deltas.map(anonymizedDeltaJson),\n        };\n    }\n}\nfunction anonymizedDeltaJson(delta) {\n    return {\n        ops: delta.ops.map(op => ({\n            // Anonymize inserts\n            [getOpType(op)]: isInsertOp(op) ? 'x'.repeat(getOpLength(op)) : getOpLength(op),\n            // Anonymize attributes\n            ...(op.attributes\n                ? {\n                    attributes: {\n                        ...op.attributes,\n                        ...('link' in op.attributes ? { link: 'x' } : {}),\n                    },\n                }\n                : {}),\n        })),\n    };\n}\n\nexport { RangeRebasingError, TextRangeManager };\n//# sourceMappingURL=TextRangeManager-EblcS8.mjs.map\n"],"names":["union","a","ranges","r","intersect","b","widen","amount","minMax","isCollapsed","range","toString","getBit","flags","bitIndex","setBit","clearBit","NodeColor","NodeEditBehavior","ColorBit","IsVisitedBit","EditBehaviorBit","MIN_SAFE_DELTA","MAX_SAFE_DELTA","getNodeColor","node","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeEditBehavior","setNodeEditBehavior","editBehavior","_IntervalNode","start","end","behavior","onBeforeEditOperation","__publicField","revision","absoluteStart","absoluteEnd","cachedRevision","_IntervalNode_static","createSentinel_fn","sentinel","__privateAdd","__privateMethod","_a","IntervalNode","IntervalTree","_IntervalTree_instances","intervalSearch","getAllInOrder","rbTreeInsert","rbTreeDelete","initialNode","offset","logger","nodeStart","nodeEnd","change","affectedNodes","pos","op","isRetainOp","isInsertOp","nodes","acceptInsert_fn","getOpLength","isDeleteOp","acceptDelete_fn","normalizeOffset","text","nodesOfInterest","searchNodesInEditRange","i","len","shiftNodesAfterEdit","nodeAcceptInsert","deletionLength","nodeAcceptDelete","T","recomputeMaxEnd","isWordBreakCharacter","char","c","insertIsWordBreak","trimStart","newLength","nodeMaxEnd","result","resultLen","newTextLength","editDelta","results","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","maxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TextRangeManager","options","_TextRangeManager_instances","_logger","_liveRanges","_intervalTree","_idSequence","IdSequence","_history","CircularBuffer","__privateSet","__privateGet","Delta","affectedRanges","isNonNullable","firstOp","changeStart","getChangedRanges","concatAffectedAndChangedRanges","pipe","map","filter","rebaseRangeOnLatestRevision_fn","create","Result.map","rebasedRange","liveRange","DefaultLiveTextRange","toArray","textRangeAddOptions","expectedRevision","updateSemantics","Result.success","deltas","getChangesSince_fn","delta","TextRangeUpdateSemantics","Result.failure","RangeRebasingError","_intervalNode","_disposables","changedRanges","affectedRangesSet","UnreachableCaseError","CustomError","details","anonymizedDeltaJson","getOpType"],"mappings":"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"}