var I=Object.defineProperty;var m=(t,e,n)=>e in t?I(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var p=(t,e,n)=>m(t,typeof e!="symbol"?e+"":e,n);function N(t,e=t){let n;return{get(){return n===void 0&&(n=t()),n},update(s){n!==void 0&&(n=e(s,this.get()))},clear(){n=void 0}}}function o(t){return t.delete!==void 0}function c(t){return t.insert!==void 0}function f(t){return t.retain!==void 0}function x(t){return c(t)&&typeof t.insert=="string"}function w(t,e){const n=t.attributes,s=e.attributes;return L(n,s)}function j(t,e){if(t===e)return!0;if(t===void 0||e===void 0)return!1;const n=b(t),s=b(t);return n!==s?!1:L(t[n],e[s])&&w(t,e)}function L(t,e){if(t===e)return!0;if(typeof t!="object"||typeof e!="object"||t===null||e===null)return!1;const n=Object.keys(t);if(n.length!==Object.keys(e).length)return!1;for(const s of n)if(t[s]!==e[s])return!1;return!0}function d(t){return c(t)?typeof t.insert=="string"?t.insert.length:1:f(t)?t.retain:t.delete}function b(t){return c(t)?"insert":f(t)?"retain":"delete"}function T(t){return l({...t,insert:c(t)?typeof t.insert=="object"?JSON.parse(JSON.stringify(t.insert)):t.insert:void 0,attributes:t.attributes!==void 0?{...t.attributes}:t.attributes})}function l(t){return{insert:t.insert,delete:t.delete,retain:t.retain,attributes:t.attributes}}class O{constructor(e){p(this,"ops");p(this,"index");p(this,"offset");this.ops=e,this.index=0,this.offset=0}hasNext(){return this.peekLength()<1/0}next(e=1/0){const n=this.ops[this.index];let s;if(n!==void 0){const i=this.offset,r=d(n);e>=r-i?(e=r-i,this.index+=1,this.offset=0):this.offset+=e,o(n)?s=l({delete:e}):f(n)?s={retain:e,attributes:n.attributes}:x(n)?s=l({insert:n.insert.slice(i,i+e),attributes:n.attributes}):s=n}else s=l({retain:1/0});return s}peek(){return this.ops[this.index]}peekLength(){const e=this.ops[this.index];return e!==void 0?d(e)-this.offset:1/0}peekType(){const e=this.ops[this.index];return e!==void 0?b(e):"retain"}rest(){if(this.hasNext()){if(this.offset===0)return this.ops.slice(this.index);{const e=this.offset,n=this.index,s=this.next(),i=this.ops.slice(this.index);return this.offset=e,this.index=n,[s].concat(i)}}else return[]}}function a(t,e){return e!==void 0&&Object.keys(e).length>0?{...t,attributes:e}:{...t,attributes:void 0}}function _(t){for(;t.ops.length>0;){const e=t.ops[t.ops.length-1];if(e!==void 0&&f(e)&&e.attributes===void 0)t.ops.pop();else break}return t}class k{constructor(e){p(this,"_ops");p(this,"_changeLength",N(()=>this._ops.reduce((e,n)=>c(n)?e+d(n):o(n)?e-n.delete:e,0),(e,n)=>c(e)?n+d(e):o(e)?n-e.delete:n));this._ops=J(e),this._ops.length===0&&this.changeLength}get ops(){return this._ops}get changeLength(){return this._changeLength.get()}insert(e,n){return typeof e=="string"&&e.length===0?this:this.push(a({insert:e},n))}delete(e){return e<=0?this:this.push({delete:e})}retain(e,n){return e<=0?this:this.push(a({retain:e},n))}push(...e){if(e.length===0)return this;const n=e[0];this._changeLength.update(n);let s=this._ops.length,i=this._ops[s-1];const r=T(n);if(i!==void 0){if(o(r)&&o(i))return this._ops[s-1]=l({delete:i.delete+r.delete}),this;if(o(i)&&c(r)&&(s-=1,i=this._ops[s-1],i===void 0))return this._ops.unshift(r),this;if(w(r,i)){if(x(r)&&x(i))return this._ops[s-1]=l(a({insert:i.insert+r.insert},r.attributes)),this;if(f(r)&&f(i))return this._ops[s-1]=l(a({retain:i.retain+r.retain},r.attributes)),this}}if(s===this._ops.length?this._ops.push(r):this._ops.splice(s,0,r),e.length>1){const u=e.slice(1);this._ops.push(...u),u.forEach(h=>{this._changeLength.update(h)})}return this}slice(e=0,n=1/0){const s=[],i=new O(this._ops);let r=0;for(;r<n&&i.hasNext();){let u;r<e?u=i.next(e-r):(u=i.next(n-r),s.push(u)),r+=d(u)}return new k(s)}compose(e){return S(this,new k,e)}transformPosition(e,n=!1){const s=new O(this._ops);let i=0;for(;s.hasNext()&&i<=e;){const r=s.peekLength(),u=s.peekType();if(s.next(),u==="delete"){e-=Math.min(r,e-i);continue}else u==="insert"&&(!n||i<e)&&(e+=r);i+=r}return e}toJSON(){return JSON.stringify({ops:this._ops})}toRaw(){return{ops:this._ops}}}function A(t={},e={},n=!1){const s=n?{...e}:{};if(!n)for(const i of Object.entries(e))i[1]!==null&&(s[i[0]]=i[1]);for(const i of Object.keys(t))t[i]!==void 0&&e[i]===void 0&&(s[i]=t[i]);return Object.keys(s).length>0?s:void 0}function J(t){return t?R(t)?t.slice():t.ops.slice():[]}function R(t){return Array.isArray(t)}function S(t,e,n){const s=new O(t.ops),i=new O(n.ops),r=i.peek();if(r!==void 0&&f(r)&&r.attributes===void 0){let u=r.retain;for(;s.peekType()==="insert"&&s.peekLength()<=u;)u-=s.peekLength(),e.push(s.next());r.retain-u>0&&i.next(r.retain-u)}for(;s.hasNext()||i.hasNext();)if(i.peekType()==="insert")e.push(i.next());else if(s.peekType()==="delete")e.push(s.next());else{const u=Math.min(s.peekLength(),i.peekLength()),h=s.next(u),g=i.next(u);if(f(g)){let y;if(f(h)?y={retain:u}:y={insert:h.insert},e.push(a(y,A(h.attributes,g.attributes,f(h)))),!i.hasNext()&&j(e.ops[e.ops.length-1],y))return _(e.push(...s.rest()))}else o(g)&&f(h)&&e.push(g)}return _(e)}export{k as D,c as a,o as b,b as c,d as g,f as i};
//# sourceMappingURL=Delta-Bv7tGR-CQrdco4K.js.map
