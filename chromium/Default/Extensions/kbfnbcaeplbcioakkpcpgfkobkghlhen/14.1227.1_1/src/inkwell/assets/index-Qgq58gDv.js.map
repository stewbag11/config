{"version":3,"file":"index-Qgq58gDv.js","sources":["../../../util-transform/dist/TransformManager-yhI8pE.mjs","../../../feature-suggestion/src/SuggestionManager.ts","../../../feature-suggestion/src/index.ts"],"sourcesContent":["import { TextRangeManager, TextRangeUpdateSemantics } from '@grammarly/util-text';\nimport { Delta } from '@grammarly/util-delta';\nimport { pipe } from '@grammarly/util-function';\nimport { map } from '@grammarly/util-iterable';\nimport { dispose } from '@grammarly/util-disposable';\nimport { Result } from '@grammarly/util-result';\n\n/**\n * A manager responsible for keeping a collection of transforms up-to-date with text changes.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TransformManager {\n    #textRangeManager;\n    constructor(options) {\n        this.#textRangeManager = new TextRangeManager({\n            ...options,\n            initialTextRevision: options.textContent.revision,\n            label: 'TransformManager/TextRangeManager',\n        });\n        // Consume initial text change\n        this.pushTextChange({\n            change: options.textContent.content,\n            revision: options.textContent.revision,\n        });\n    }\n    /** {@inheritdoc TransformManager.pushTextChange} */\n    pushTextChange({ change, revision }) {\n        const result = this.#textRangeManager.pushTextChange({ change, revision });\n        const affectedTransforms = [];\n        for (const range of result.affectedRanges) {\n            affectedTransforms.push(range.metadata);\n            range.metadata.onEditComplete(change);\n        }\n        return {\n            getChangedTransforms: () => pipe(result.getChangedRanges(), map(r => r.metadata)),\n            affectedTransforms,\n        };\n    }\n    /** {@inheritdoc TransformManager.add} */\n    add({ context, alternatives, metadata, revision, }) {\n        const liveRange = this.#textRangeManager.add({\n            range: context,\n            revision,\n            updateSemantics: TextRangeUpdateSemantics.Resize,\n            metadata: new DefaultLiveTransform({\n                getTextRange: () => (liveRange.ok ? liveRange.value : context),\n                getRevision: () => (liveRange.ok ? liveRange.value.revision : revision),\n                onDispose: () => dispose(liveRange),\n                alternatives,\n                metadata,\n            }),\n            onBeforeEditOperation: (offset, op) => pipe(liveRange, Result.map(range => range.metadata.onBeforeEditOperation(offset, op))),\n        });\n        return pipe(liveRange, Result.map(range => range.metadata));\n    }\n    [Symbol.dispose]() {\n        dispose(this.#textRangeManager);\n    }\n}\n/**\n * Default implementation of LiveTransform.\n * @internal\n */\nclass DefaultLiveTransform {\n    #onDispose;\n    #getTextRange;\n    #getRevision;\n    #alternatives;\n    #staleContextOffset = null;\n    metadata;\n    constructor(options) {\n        this.#onDispose = options.onDispose;\n        this.#getTextRange = options.getTextRange;\n        this.#getRevision = options.getRevision;\n        this.#alternatives = options.alternatives;\n        this.metadata = options.metadata;\n    }\n    onBeforeEditOperation(_offset, _op) {\n        if (this.#staleContextOffset !== null) {\n            this.#staleContextOffset = this.context.start;\n        }\n    }\n    onEditComplete(textChange) {\n        const staleContextOffset = this.#staleContextOffset;\n        if (staleContextOffset !== null) {\n            // TODO:(major) this is naive rebase, use Denali's Alternative.Impl logic to take into account\n            // the alternative operations types ('main' | 'important') to determine if the rebase\n            // is valid or if the delta should be discarded.\n            this.#alternatives = this.#alternatives.map(delta => delta.compose(textChange.slice(staleContextOffset)));\n            this.#staleContextOffset = null;\n        }\n    }\n    get context() {\n        const context = this.#getTextRange();\n        return { start: context.start, end: context.end };\n    }\n    get alternatives() {\n        return this.#alternatives;\n    }\n    get absoluteAlternatives() {\n        return this.#alternatives.map(delta => new Delta().retain(this.context.start).compose(delta));\n    }\n    get revision() {\n        return this.#getRevision();\n    }\n    [Symbol.dispose]() {\n        this.#onDispose();\n    }\n}\n\nexport { TransformManager };\n//# sourceMappingURL=TransformManager-yhI8pE.mjs.map\n","import type { TextDocument } from '@grammarly/feature-document-session'\nimport { NonEmptyArray } from '@grammarly/util-array'\nimport { defineDebugView } from '@grammarly/util-debugging'\nimport { Delta } from '@grammarly/util-delta'\nimport { dispose } from '@grammarly/util-disposable'\nimport { CustomError } from '@grammarly/util-error'\nimport { identity, isNonNullable, pipe } from '@grammarly/util-function'\nimport { filter, map } from '@grammarly/util-iterable'\nimport { logger, type Logger } from '@grammarly/util-logging'\nimport { Emitter, Rx } from '@grammarly/util-reactive'\nimport { AsyncResult, Result } from '@grammarly/util-result'\nimport { TransformManager, type LiveTransform } from '@grammarly/util-transform'\nimport type { ConcreteSuggestion, Suggestion, SuggestionId, SuggestionKind } from './Suggestion'\nimport type { SuggestionCollection, SuggestionCollectionChange } from './SuggestionCollection'\nimport type { SuggestionProvider } from './SuggestionProvider'\n\n/** @public */\nexport interface SuggestionManager extends Disposable {\n  register<K extends SuggestionKind>(provider: SuggestionProvider<K>): Disposable\n\n  /**\n   * Apply a suggestion\n   * @param id - The suggestion to apply\n   * @param alternativeIndex - The index of the alternative to apply\n   */\n  apply(id: SuggestionId, alternativeIndex: number): AsyncResult<void>\n\n  /**\n   * Get a collection of suggestions by kind\n   * @param kind - The kind of collection to get, if not specified, all suggestions will be returned\n   */\n  getCollection<K extends SuggestionKind = SuggestionKind>(kind?: K): SuggestionCollection<K>\n}\n\n/**\n * Responsible for managing suggestions.\n * @internal\n */\nexport class DefaultSuggestionManager implements SuggestionManager, Disposable {\n  readonly #logger: Logger\n  readonly #transformManager: TransformManager<SuggestionId>\n  readonly #suggestions = new Map<SuggestionId, SuggestionInternal<SuggestionKind>>()\n  readonly #disposables = new DisposableStack()\n  readonly #emitter = this.#disposables.use(\n    new Emitter<SuggestionCollectionChange<SuggestionKind>>(),\n  )\n  readonly #providers = new Map<SuggestionProvider<SuggestionKind>, Disposable>()\n\n  constructor(textDocument: Pick<TextDocument, 'onTextDidChange' | 'text' | 'id'>) {\n    this.#logger = logger.createLogger('SuggestionManager', textDocument.id)\n    this.#transformManager = this.#disposables.use(\n      new TransformManager({\n        textContent: textDocument.text.getValue(),\n      }),\n    )\n    this.#disposables.use(\n      textDocument.onTextDidChange.subscribe(textChange => {\n        using changeRef = textChange.take()\n        const { affectedTransforms } = this.#transformManager.pushTextChange(changeRef.value)\n        changeRef.release()\n\n        const affectedByTextChange = pipe(\n          new Set(affectedTransforms.map(alt => alt.metadata)),\n          map(id => this.#suggestions.get(id)),\n          filter(isNonNullable),\n          map(s => s.suggestion),\n          NonEmptyArray.from,\n        )\n\n        if (affectedByTextChange) {\n          this.#emitter.emit({ affectedByTextChange })\n        }\n      }),\n    )\n    this.#disposables.defer(() => {\n      const removed = NonEmptyArray.from(\n        pipe(\n          this.#suggestions.values(),\n          map(s => s.suggestion),\n        ),\n      )\n      if (removed) {\n        this.#emitter.emit({ removed })\n      }\n    })\n    defineDebugView(this, () => ({\n      suggestions: this.#suggestions,\n    }))\n  }\n\n  register<K extends SuggestionKind>(provider: SuggestionProvider<K>): Disposable {\n    const disposable = this.#providers.get(provider)\n    if (disposable) {\n      return disposable\n    }\n    const disposableStack = new DisposableStack()\n\n    disposableStack.use(\n      provider.onSuggestionUpserted.subscribe(suggestions => {\n        suggestions.forEach(s => this.#upsert(s))\n        const upserted = NonEmptyArray.from(suggestions)\n        if (upserted) {\n          this.#emitter.emit({ upserted })\n        }\n      }),\n    )\n\n    disposableStack.use(\n      provider.onSuggestionRemoved.subscribe(ids => {\n        const removed = NonEmptyArray.from(\n          ids\n            .map(id => this.#suggestions.get(id)?.suggestion as ConcreteSuggestion<K> | undefined)\n            .filter(isNonNullable),\n        )\n\n        ids.forEach(id => this.#remove(id))\n\n        if (removed) {\n          this.#emitter.emit({ removed })\n        }\n      }),\n    )\n\n    this.#providers.set(provider, disposableStack)\n    this.#disposables.use(disposableStack)\n\n    return disposableStack\n  }\n\n  apply(id: SuggestionId, alternativeIndex: number): AsyncResult<void> {\n    const suggestion = this.#suggestions.get(id)\n    if (!suggestion) {\n      return AsyncResult.failure(new SuggestionNotFoundError(id))\n    }\n\n    // Index across all transforms\n    const deltas = suggestion.transforms\n      .map(a => a.absoluteAlternatives[alternativeIndex])\n      .filter(isNonNullable)\n\n    if (deltas.length === 0) {\n      return AsyncResult.failure(new AlternativeIndexOutOfBoundsError(id, alternativeIndex))\n    }\n\n    void deltas\n\n    this.#emitter.emit({ removed: [suggestion.suggestion] })\n\n    return AsyncResult.failure(new Error('Not implemented'))\n  }\n\n  #upsert<K extends SuggestionKind>(suggestion: ConcreteSuggestion<K>): Result<void> {\n    const s = suggestion as Suggestion<K>\n\n    // TODO: maybe check if transforms change before deleting/re-inserting?\n    // overwriting the transform may break consumers using the old transforms object since this is a live transform\n    this.#remove(s.id)\n\n    // TODO: transforms are not needed yet, no need to extract and rebase them.\n    const disableTransforms = true\n\n    const transforms = Result.all(\n      disableTransforms\n        ? []\n        : s.transforms.map(t =>\n            this.#transformManager.add({\n              revision: s.revision,\n              context: t.context,\n              alternatives: t.alternatives?.map(delta => new Delta(delta)) ?? [],\n              metadata: s.id,\n            }),\n          ),\n    )\n    if (!transforms.ok) {\n      this.#logger.error('Error upserting suggestion', transforms.error)\n      this.#logger.verbose(`Error upserting suggestion ${s.id}`, transforms.error)\n      return transforms\n    }\n\n    this.#suggestions.set(s.id, {\n      suggestion,\n      transforms: transforms.value,\n    })\n\n    this.#logger.verbose(`Upserted suggestion ${s.id}`, s)\n\n    return Result.success()\n  }\n\n  #remove(id: SuggestionId): void {\n    const transforms = this.#suggestions.get(id)?.transforms\n    dispose(transforms ?? [])\n    this.#suggestions.delete(id)\n  }\n\n  getCollection<K extends SuggestionKind = SuggestionKind>(kind?: K): SuggestionCollection<K> {\n    const getAll = () =>\n      pipe(\n        this.#suggestions.values(),\n        map(s => s.suggestion),\n        kind === undefined ? identity : filter(s => (s as Suggestion<K>).kind === kind),\n      )\n\n    return {\n      onChange:\n        kind === undefined\n          ? this.#emitter\n          : pipe(\n              Rx.fromSubscribable(this.#emitter),\n              Rx.map(filterCollectionChange(kind)),\n              Rx.filter(isNonNullable),\n              Rx.toSubscribable,\n            ),\n      getAll,\n      getById: id => this.#suggestions.get(id)?.suggestion ?? null,\n      clear: () => {\n        const suggestions = NonEmptyArray.from(getAll())\n        if (suggestions) {\n          suggestions.forEach(dispose)\n          this.#emitter.emit({ removed: suggestions })\n        }\n      },\n    }\n  }\n\n  [Symbol.dispose]() {\n    this.#disposables.dispose()\n  }\n}\n\nfunction filterCollectionChange<K extends SuggestionKind>(\n  kind: K,\n): (change: SuggestionCollectionChange<SuggestionKind>) => SuggestionCollectionChange<K> | null {\n  return change => {\n    const isSuggestionKind = (s: unknown): s is Suggestion<K> => (s as Suggestion<K>).kind === kind\n\n    const filteredChange = {\n      upserted: NonEmptyArray.from(change.upserted?.filter(isSuggestionKind) ?? []) ?? undefined,\n      removed: NonEmptyArray.from(change.removed?.filter(isSuggestionKind) ?? []) ?? undefined,\n      affectedByTextChange:\n        NonEmptyArray.from(change.affectedByTextChange?.filter(isSuggestionKind) ?? []) ??\n        undefined,\n    }\n\n    if (filteredChange.upserted || filteredChange.removed || filteredChange.affectedByTextChange) {\n      return filteredChange\n    }\n    return null\n  }\n}\n\ninterface SuggestionInternal<K extends SuggestionKind> {\n  readonly suggestion: ConcreteSuggestion<K>\n  readonly transforms: readonly LiveTransform[]\n}\n\nexport class SuggestionNotFoundError extends CustomError {\n  constructor(id: SuggestionId) {\n    super(`Suggestion ${id} was not found.`)\n  }\n}\n\nexport class AlternativeIndexOutOfBoundsError extends CustomError {\n  constructor(id: SuggestionId, alternativeIndex: number) {\n    super(`Alternative index ${alternativeIndex} for Suggestion ${id} is out of bounds.`)\n  }\n}\n","/**\n * This feature packages is responsible for managing suggestions coming from Grammarly's backend.\n * It keeps their transforms in sync with text changes, and offers an API to query suggestions\n * and apply them.\n * @packageDocumentation\n */\n\nexport type {\n  ConcreteSuggestion,\n  Suggestion,\n  SuggestionId,\n  SuggestionKind,\n  SuggestionRegistry,\n  TransformJson,\n} from './Suggestion'\nexport type { SuggestionCollection, SuggestionCollectionChange } from './SuggestionCollection'\nexport type { SuggestionManager } from './SuggestionManager'\nexport type { SuggestionProvider } from './SuggestionProvider'\n\nimport type { Activate } from '@grammarly/feature'\nimport { createInjectionToken, defineFactory, Lifetime } from '@grammarly/util-dependency-container'\nimport { pipe } from '@grammarly/util-function'\nimport { Result } from '@grammarly/util-result'\nimport { type SuggestionManager, DefaultSuggestionManager } from './SuggestionManager'\n\nimport type {} from '@grammarly/feature-document-session'\n\n/** @public */\nexport const SuggestionManagerToken = createInjectionToken<SuggestionManager>(\n  Symbol('SuggestionManager'),\n)\n\n/** @public */\nexport const activate: Activate = context =>\n  pipe(\n    Result.all([\n      context.getExecutionScope('document-session'),\n      context.getFeature('document-session'),\n    ] as const),\n    Result.flatMap(([documentSessionScope, documentSession]) =>\n      documentSessionScope.register(\n        {\n          token: SuggestionManagerToken,\n          useFactory: defineFactory(DefaultSuggestionManager, [\n            documentSession.provides.TextDocument,\n          ]),\n        },\n        { lifetime: Lifetime.ContainerScoped },\n      ),\n    ),\n  )\n"],"names":["TransformManager","options","__privateAdd","_textRangeManager","__privateSet","TextRangeManager","change","revision","result","__privateGet","affectedTransforms","range","pipe","map","context","alternatives","metadata","liveRange","TextRangeUpdateSemantics","DefaultLiveTransform","dispose","offset","op","Result.map","_onDispose","_getTextRange","_getRevision","_alternatives","_staleContextOffset","__publicField","_offset","_op","textChange","staleContextOffset","delta","Delta","_logger","_transformManager","_suggestions","_disposables","_emitter","_providers","_DefaultSuggestionManager_instances","upsert_fn","remove_fn","DefaultSuggestionManager","textDocument","Emitter","logger","_stack","changeRef","__using","affectedByTextChange","alt","id","filter","isNonNullable","s","NonEmptyArray.from","_","_error","_hasError","__callDispose","removed","provider","disposable","disposableStack","suggestions","__privateMethod","upserted","ids","_a","alternativeIndex","suggestion","a","AsyncResult.failure","AlternativeIndexOutOfBoundsError","SuggestionNotFoundError","kind","getAll","identity","Rx","filterCollectionChange","_b","transforms","Result.all","Result.success","_c","_d","_e","_f","_g","_h","_i","isSuggestionKind","filteredChange","CustomError","SuggestionManagerToken","createInjectionToken","activate","Result.flatMap","documentSessionScope","documentSession","defineFactory","Lifetime"],"mappings":"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"}