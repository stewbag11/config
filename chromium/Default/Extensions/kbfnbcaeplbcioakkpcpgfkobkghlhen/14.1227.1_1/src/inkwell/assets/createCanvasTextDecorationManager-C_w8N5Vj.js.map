{"version":3,"file":"createCanvasTextDecorationManager-C_w8N5Vj.js","sources":["../../../../node_modules/.pnpm/quickselect@2.0.0/node_modules/quickselect/index.js","../../../../node_modules/.pnpm/rbush@4.0.0/node_modules/rbush/index.js","../../../util-geometry/dist/InteractiveGeometryManager-BdQhJT.mjs","../../../util-geometry/dist/ContentRectFns-C1G17h.mjs","../../../util-geometry/dist/mergeHorizontallyAdjacentRects-Cw4maJ.mjs","../../../util-geometry/dist/getLineBoundingBoxes-CLwZ_-.mjs","../../../util-geometry/dist/TextAndGeometryRevisionFns-Dy6shQ.mjs","../../../util-text-range-geometry/dist/TextRangeGeometryManager-DwDHZb.mjs","../../../feature-text-decoration/src/CanvasInspector.ts","../../../feature-text-decoration/src/animation.ts","../../../feature-text-decoration/src/CanvasRenderer.ts","../../../feature-text-decoration/src/CanvasTextDecoration.ts","../../../feature-text-decoration/src/CanvasTextDecorationManager.ts","../../../feature-text-decoration/src","../../../feature-text-decoration/src/createCanvasTextDecorationManager.ts?comlink=expose"],"sourcesContent":["\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import { pipe, identity, isNonNullable } from '@grammarly/util-function';\nimport { flatMap, toArray, map, filter } from '@grammarly/util-iterable';\nimport { logger } from '@grammarly/util-logging';\nimport { Emitter, Rx } from '@grammarly/util-reactive';\nimport { createSingletonTaskQueue, microtaskScheduler } from '@grammarly/util-scheduling';\nimport { tracer } from '@grammarly/util-tracing';\nimport RBush from 'rbush';\nimport { contains } from './RectFns-D2VKzQ.mjs';\n\n/**\n * A Manager that stores a collection of rectangles and allows listening to pointer events for the registered geometry.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass InteractiveGeometryManager {\n    #logger;\n    #disposables = new DisposableStack();\n    #compareZIndex;\n    #pointerPositionThrottleTimeMs;\n    #geometryToRects = new Map();\n    #rectToGeometry = new Map();\n    // When compareZIndex is not provided, we use insertion order for the z-index, and track it in this map\n    // Geometry inserted last is considered higher and wins.\n    #rectToZIndex = null;\n    #upsertQueue = new Map();\n    #removeQueue = new Set();\n    #rTree = new RTree();\n    #getViewport;\n    #emitMetrics;\n    #flushQueue = this.#disposables.use(createSingletonTaskQueue(() => this.#flushQueues(), microtaskScheduler));\n    #nextZIndex = 0;\n    #enabled = true;\n    #currentHoveredGeometry = null;\n    #currentPointerDownGeometry = null;\n    #pointerEventEmitter = new Emitter();\n    /** {@inheritdoc InteractiveGeometryManager.onPointerEvent} */\n    onPointerEvent = this.#pointerEventEmitter;\n    constructor(options) {\n        this.#logger = logger.createLogger('InteractiveGeometryManager', options.label);\n        this.#emitMetrics = options.emitMetrics;\n        this.#pointerPositionThrottleTimeMs = options.pointerPositionThrottleTimeMs ?? 1000 / 30;\n        const throttledMouseMove = pipe(Rx.fromSubscribable(options.pointerMove), this.#pointerPositionThrottleTimeMs === 0\n            ? identity\n            : Rx.throttleTime(this.#pointerPositionThrottleTimeMs));\n        this.#getViewport = options.getViewport;\n        this.#disposables.use(pipe(throttledMouseMove, Rx.subscribe(position => this.#handlePointerMove(position))));\n        this.#disposables.use(options.pointerDown.subscribe(event => this.#handlePointerDown(event)));\n        this.#disposables.use(options.pointerUp.subscribe(event => this.#handlePointerUp(event)));\n        this.#rectToZIndex = options.compareZIndex ? null : new Map();\n        this.#compareZIndex =\n            options.compareZIndex ??\n                ((a, b) => (this.#rectToZIndex?.get(a.rect) ?? 0) - (this.#rectToZIndex?.get(b.rect) ?? 0));\n        this.#disposables.defer(() => this.clear());\n    }\n    async upsert(geometry, rects) {\n        this.#removeQueue.delete(geometry);\n        this.#upsertQueue.set(geometry, rects);\n        await this.#flushQueue.enqueue();\n    }\n    async remove(geometry) {\n        this.#upsertQueue.delete(geometry);\n        this.#removeQueue.add(geometry);\n        await this.#flushQueue.enqueue();\n    }\n    clear() {\n        this.#rTree.clear();\n        this.#geometryToRects.clear();\n        this.#rectToGeometry.clear();\n        this.#rectToZIndex?.clear();\n        this.#upsertQueue.clear();\n        this.#removeQueue.clear();\n        this.#flushQueue.cancel();\n        this.#emitMetrics?.({ interactiveRectCount: 0 });\n    }\n    disablePointerEvents() {\n        this.#enabled = false;\n        this.#emitMetrics?.({ interactiveRectCount: 0 });\n    }\n    enablePointerEvents() {\n        this.#enabled = true;\n        this.#emitMetrics?.({ interactiveRectCount: this.#rTree.size });\n    }\n    #flushQueues() {\n        const rectsToRemove = pipe(this.#removeQueue, flatMap(geometry => this.#geometryToRects.get(geometry) ?? []), toArray);\n        const rectsToUpdate = pipe(this.#upsertQueue, map(([geometry, rects]) => [this.#geometryToRects.get(geometry) ?? [], rects]), toArray);\n        if (rectsToRemove.length === 0 && rectsToUpdate.length === 0) {\n            return;\n        }\n        using _ = tracer.startSpan('InteractiveGeometryManager.flushQueues()', {\n            attributes: {\n                removals: rectsToRemove.length,\n                updates: rectsToUpdate.length,\n                treeSize: this.#rTree.size,\n            },\n        });        // Delete removed geometry\n        for (const rect of rectsToRemove) {\n            this.#rTree.remove(rect);\n            this.#rectToGeometry.delete(rect);\n            this.#rectToZIndex?.delete(rect);\n        }\n        for (const geometry of this.#removeQueue) {\n            this.#geometryToRects.delete(geometry);\n            if (this.#currentHoveredGeometry?.geometry === geometry) {\n                this.#currentHoveredGeometry = null;\n            }\n        }\n        // Delete rects that will be updated\n        for (const [rects, _] of rectsToUpdate) {\n            for (const rect of rects) {\n                this.#rTree.remove(rect);\n            }\n        }\n        // Add new rects and associate them with geometries\n        for (const [geometry, rects] of this.#upsertQueue) {\n            for (const rect of rects) {\n                this.#rectToGeometry.set(rect, geometry);\n                this.#rectToZIndex?.set(rect, this.#nextZIndex++);\n            }\n            this.#geometryToRects.set(geometry, rects);\n        }\n        // Bulk-load the new rects\n        this.#rTree.load(rectsToUpdate.flatMap(([_, rects]) => rects));\n        this.#removeQueue.clear();\n        this.#upsertQueue.clear();\n        this.#emitMetrics?.({ interactiveRectCount: this.#rTree.size });\n        this.#logger.verbose('queue flushed', {\n            removals: rectsToRemove.length,\n            updates: rectsToUpdate.length,\n            treeSize: this.#rTree.size,\n        });\n    }\n    #handlePointerMove(position) {\n        const target = this.#getTopMostIntersection(position);\n        const events = {};\n        if (target) {\n            // Ignore pointer-move over the same geometry\n            if (this.#currentHoveredGeometry?.geometry === target.geometry) {\n                return;\n            }\n            // Hovered geometry changed (or nothing was hovered before)\n            if (this.#currentHoveredGeometry !== null &&\n                this.#currentHoveredGeometry.geometry !== target.geometry) {\n                events.pointerLeave = {\n                    kind: 'pointerLeave',\n                    position,\n                    currentTarget: this.#currentHoveredGeometry.rect,\n                    target: this.#currentHoveredGeometry.geometry,\n                };\n            }\n            events.pointerEnter = {\n                kind: 'pointerEnter',\n                position,\n                currentTarget: target.rect,\n                target: target.geometry,\n            };\n            this.#currentHoveredGeometry = target;\n        }\n        // Hovered geometry is no longer hovered\n        else if (this.#currentHoveredGeometry !== null) {\n            events.pointerLeave = {\n                kind: 'pointerLeave',\n                position,\n                currentTarget: this.#currentHoveredGeometry.rect,\n                target: this.#currentHoveredGeometry.geometry,\n            };\n            this.#currentHoveredGeometry = null;\n        }\n        if (Object.values(events).some(isNonNullable)) {\n            this.#pointerEventEmitter.emit(events);\n        }\n    }\n    #handlePointerDown(position) {\n        const target = this.#getTopMostIntersection(position);\n        if (!target)\n            return;\n        this.#currentPointerDownGeometry = target.geometry;\n        this.#pointerEventEmitter.emit({\n            pointerDown: {\n                kind: 'pointerDown',\n                position,\n                currentTarget: target.rect,\n                target: target.geometry,\n            },\n        });\n    }\n    #handlePointerUp(position) {\n        const target = this.#getTopMostIntersection(position);\n        if (!target)\n            return;\n        const events = {\n            pointerUp: {\n                kind: 'pointerUp',\n                position,\n                currentTarget: target.rect,\n                target: target.geometry,\n            },\n        };\n        // Emit a click if both pointer-down and pointer-up are on the same geometry\n        if (this.#currentPointerDownGeometry === target.geometry) {\n            events.pointerClick = {\n                kind: 'pointerClick',\n                position,\n                currentTarget: target.rect,\n                target: target.geometry,\n            };\n        }\n        this.#currentPointerDownGeometry = null;\n        if (Object.values(events).some(isNonNullable)) {\n            this.#pointerEventEmitter.emit(events);\n        }\n    }\n    #getTopMostIntersection(position) {\n        if (!contains(this.#getViewport(), position) || !this.#enabled)\n            return null;\n        return pipe(this.#rTree.search({\n            minX: position.x,\n            minY: position.y,\n            maxX: position.x,\n            maxY: position.y,\n        }), map(rect => pipe(this.#rectToGeometry.get(rect), geometry => (geometry ? { rect, geometry } : null))), filter(isNonNullable), toArray, \n        // Return top-most intersection\n        intersections => intersections.sort((a, b) => this.#compareZIndex(a, b)).at(-1) ?? null);\n    }\n    [Symbol.dispose]() {\n        this.#disposables.dispose();\n    }\n}\nclass RTree extends RBush {\n    _rects = new Set();\n    toBBox(rect) {\n        return { minX: rect.x, minY: rect.y, maxX: rect.x + rect.width, maxY: rect.y + rect.height };\n    }\n    compareMinX(a, b) {\n        return a.x - b.x;\n    }\n    compareMinY(a, b) {\n        return a.y - b.y;\n    }\n    load(items) {\n        items.forEach(item => this._rects.add(item));\n        return super.load(items);\n    }\n    insert(item) {\n        this._rects.add(item);\n        return super.insert(item);\n    }\n    remove(item, equals) {\n        this._rects.delete(item);\n        return super.remove(item, equals);\n    }\n    clear() {\n        // Clear is called in RBush constructor when this._rects isn't defined yet, hence the `?`\n        this._rects?.clear();\n        return super.clear();\n    }\n    get size() {\n        return this._rects.size;\n    }\n}\n\nexport { InteractiveGeometryManager };\n//# sourceMappingURL=InteractiveGeometryManager-BdQhJT.mjs.map\n","/**\n * Create a ContentRect.\n * @public\n */\nfunction create(r) {\n    return r;\n}\n/**\n * Map a function of the rectangle components\n * @public\n * @param fn - Function to map over the rectangle components\n */\nfunction map(fn) {\n    return x => create({ x: fn(x.x), y: fn(x.y), width: fn(x.width), height: fn(x.height) });\n}\n\nexport { create, map };\n//# sourceMappingURL=ContentRectFns-C1G17h.mjs.map\n","import { create } from './RectFns-D2VKzQ.mjs';\nimport { equal } from '@grammarly/util-math';\n\n/**\n * This function merges horizontally adjacent range rectangles into a single rectangle.\n * If the adjacent ranges are of different height and have different top coordinate,\n * the maximal height and minimal top is used in the resulting rectangle.\n *\n * It's needed for cases when a range encompasses several HTML nodes that have\n * different style/formatting and can therefore have different dimensions.\n * In that case the range will return an array of adjacent rects that are\n * possibly misaligned vertically (have different top and/or height). But\n * we still want an underline of such range to look like a solid straight\n * line, so we try to collate those rectangles into a single rect.\n *\n * **It is assumed that the input rectangles will be ordered left to right and top to bottom.**\n *\n * @param rects - The rectangles to collate\n * @param xAdjacencyEpsilon - Horizontal adjacency check error. This number defines how far two rectangles\n * can be from each other while still considered adjacent horizontally.\n * Unit is number of pixels.\n * @param yAdjacencyEpsilon - Vertical adjacency check error. If two rectables overlap more than yAdjsEps pixels vertically, they will be merged.\n * @public\n */\nfunction mergeHorizontallyAdjacentRects(rects, xAdjacencyEpsilon = 1.5, yAdjacencyEpsilon = 1.5) {\n    if (rects.length === 0) {\n        return [];\n    }\n    if (rects.length === 1) {\n        return [rects[0]];\n    }\n    const res = [];\n    let collatedR = rects[0];\n    const rectsCount = rects.length;\n    for (let i = 1; i < rectsCount; i++) {\n        const nextR = rects[i];\n        const nextRBottom = nextR.y + nextR.height;\n        // Check if the next rectangle appears in the expected order (left to right, top to bottom), otherwise, skip it\n        // It happens that getClientRects() returns some rectangles out of order.\n        // no vertical intersection\n        const striclyAboveCollated = nextRBottom < collatedR.y;\n        // adjacent vertically, and both rects have non-zero heights and widths\n        const aboveCollated = equal(nextRBottom, collatedR.y) && nextR.height > 0 && collatedR.height > 0;\n        if (striclyAboveCollated || aboveCollated) {\n            continue;\n        }\n        const minLeft = Math.min(collatedR.x, nextR.x);\n        const minTop = Math.min(collatedR.y, nextR.y);\n        const maxRight = Math.max(collatedR.x + collatedR.width, nextR.x + nextR.width);\n        const maxBottom = Math.max(collatedR.y + collatedR.height, nextRBottom);\n        const unionWidth = maxRight - minLeft;\n        const unionHeight = maxBottom - minTop;\n        // Check that the projections of the heights/widths of the rectangles\n        // on the Y/X axes are less than their total height/widths (overlap).\n        // merging if horizontal distance is at most xAdjsEps\n        const hasHorizontalOverlap = unionWidth <= collatedR.width + nextR.width + xAdjacencyEpsilon;\n        // merging if rects have a vertical overlap of at least yAdjsEps\n        const hasVerticalOverlap = unionHeight <= collatedR.height + nextR.height - yAdjacencyEpsilon;\n        // we merge rects that have no height and are adjacent\n        const degenerateRectAdjacentVertical = equal(unionHeight, collatedR.height + nextR.height) &&\n            (equal(nextR.height, 0) || equal(collatedR.height, 0));\n        // if we get a rect that's equal to the collated rect so far, no need to merge it, go to next\n        if (equal(nextR.width, collatedR.width) &&\n            equal(nextR.height, collatedR.height) &&\n            equal(nextR.x, collatedR.x) &&\n            equal(nextR.y, collatedR.y)) {\n            continue;\n        }\n        else if (hasHorizontalOverlap && (hasVerticalOverlap || degenerateRectAdjacentVertical)) {\n            // expand the current collated result to include the next\n            // adjacent rectangle\n            collatedR = create({\n                y: minTop,\n                x: minLeft,\n                height: unionHeight,\n                width: unionWidth,\n            });\n        }\n        else {\n            // next rectangle is not adjacent to previous one --\n            // flush the current collated result and start a new one\n            res.push(collatedR);\n            collatedR = nextR;\n        }\n    }\n    // flush the leftover rectangle\n    res.push(collatedR);\n    return res;\n}\n\nexport { mergeHorizontallyAdjacentRects };\n//# sourceMappingURL=mergeHorizontallyAdjacentRects-Cw4maJ.mjs.map\n","import { pipe } from '@grammarly/util-function';\nimport { mergeHorizontallyAdjacentRects } from './mergeHorizontallyAdjacentRects-Cw4maJ.mjs';\n\n/**\n * This function takes raw range rectangles and merges them horizontally\n * to produce line bounding boxes that are adjacent to each other horizontally.\n * @public\n */\nfunction getLineBoundingBoxes(rects) {\n    return pipe(rects, sortRectsTopToBottomLeftToRight, mergeHorizontallyAdjacentRects);\n}\n/** @internal */\nfunction sortRectsTopToBottomLeftToRight(rects) {\n    return [...rects].sort((a, b) => {\n        if (a.y < b.y)\n            return -1;\n        if (a.y > b.y)\n            return 1;\n        if (a.x < b.x)\n            return -1;\n        if (a.x > b.x)\n            return 1;\n        return 0;\n    });\n}\n\nexport { getLineBoundingBoxes };\n//# sourceMappingURL=getLineBoundingBoxes-CLwZ_-.mjs.map\n","/**\n * Returns `true` if revision `a` is greater than revision `b`.\n * @public\n */\nfunction isGreater(a, b) {\n    return ((a.text > b.text && a.geometry >= b.geometry) || (a.geometry > b.geometry && a.text >= b.text));\n}\n/**\n * Returns `true` if revision `a` is greater than or equal to revision `b`\n * @public\n */\nfunction isGreaterOrEqual(a, b) {\n    return a.text >= b.text && a.geometry >= b.geometry;\n}\n/**\n * Convert a TextAndGeometryRevision to a printable string\n * @public\n */\nfunction toString({ text, geometry }) {\n    return `Revision({ text: ${text}, geometry: ${geometry} })`;\n}\n\nexport { isGreater, isGreaterOrEqual, toString };\n//# sourceMappingURL=TextAndGeometryRevisionFns-Dy6shQ.mjs.map\n","import { NonEmptyArray } from '@grammarly/util-array';\nimport { dispose } from '@grammarly/util-disposable';\nimport { pipe, isNonNullable, sideEffect, identity } from '@grammarly/util-function';\nimport { TextAndGeometryRevision, getLineBoundingBoxes } from '@grammarly/util-geometry';\nimport { isTest } from '@grammarly/util-is-dev';\nimport { map, filter, dedupe, toArray, takeWhile, groupBy } from '@grammarly/util-iterable';\nimport { logger } from '@grammarly/util-logging';\nimport { Rx } from '@grammarly/util-reactive';\nimport { Result, AsyncResult } from '@grammarly/util-result';\nimport { TextRange, TextRangeManager } from '@grammarly/util-text';\nimport { tracer } from '@grammarly/util-tracing';\nimport { IdSequence } from '@grammarly/util-uuid';\n\n/**\n * This manager is responsible for computing the geometry of groups of text ranges.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextRangeGeometryManager {\n    #logger = logger.createLogger('TextRangeGeometryManager');\n    #disposables = new DisposableStack();\n    #idSequence = new IdSequence();\n    #visibleTextRangePadding = 100;\n    #textRangeManager;\n    #liveRangesToGroups = new Map();\n    #idToGeometry = new Map();\n    #visibleGeometry = new Set();\n    #dirtyGeometry = new Map();\n    #requestUpdateDirtyGeometry = new Rx.Subject();\n    #emitMetrics;\n    #visibleTextRange;\n    #revision;\n    #geometryUpdateEnabled = true;\n    #getRects;\n    #getBoundingRects;\n    constructor(options) {\n        this.#getRects = options.getRects;\n        this.#getBoundingRects = options.getBoundingRects;\n        this.#emitMetrics = options.emitMetrics;\n        this.#revision = options.initialRevision;\n        this.#visibleTextRange = TextRange.isCollapsed(options.initialVisibleTextRange)\n            ? options.initialVisibleTextRange\n            : TextRange.widen(options.initialVisibleTextRange, this.#visibleTextRangePadding);\n        this.#textRangeManager = this.#disposables.use(new TextRangeManager({\n            initialTextRevision: options.initialRevision.text,\n            label: 'TextRangeGeometryManager/TextRangeManager',\n        }));\n        this.#disposables.use(pipe(this.#requestUpdateDirtyGeometry, \n        // This will group all emissions happening in the same frame and emit once at the end of the frame\n        Rx.debounceTime(0), Rx.exhaustMapWithTrailing(() => this.#requestGeometryForDirtyGroups()), Rx.subscribe()));\n        this.#disposables.defer(() => {\n            this.#liveRangesToGroups.clear();\n            this.#idToGeometry.clear();\n            this.#visibleGeometry.clear();\n        });\n    }\n    /** Only accessible in test mode */\n    get _revisionForTests() {\n        if (!isTest) {\n            throw new Error('Only available for accessing the revision in tests');\n        }\n        return { ...this.#revision };\n    }\n    disableGeometryUpdate() {\n        this.#geometryUpdateEnabled = false;\n    }\n    enableGeometryUpdate() {\n        this.#geometryUpdateEnabled = true;\n        this.#requestUpdateDirtyGeometry.next();\n    }\n    add({ id, geometryKind, metadata, revision, ranges, visible, }) {\n        const liveRangesResult = Result.all(pipe(ranges, NonEmptyArray.map(({ id, range, metadata, updateSemantics }) => this.#textRangeManager.add({\n            id: id ?? this.#idSequence.next(),\n            range,\n            metadata,\n            revision,\n            updateSemantics,\n        }))));\n        if (!liveRangesResult.ok) {\n            return liveRangesResult;\n        }\n        const liveRanges = liveRangesResult.value;\n        const rangeGroup = new DefaultLiveTextRangeGroupWithGeometry({\n            id,\n            ranges: liveRanges,\n            geometryKind,\n            metadata: metadata,\n            enqueueGetRects: minimumRevision => {\n                const dirtyGeometryState = this.#dirtyGeometry.get(rangeGroup);\n                if (!dirtyGeometryState ||\n                    TextAndGeometryRevision.isGreater(minimumRevision, dirtyGeometryState.revision)) {\n                    this.#enqueueGeometryUpdateFor([rangeGroup], 'enqueueGetRects', true);\n                }\n            },\n            onDispose: () => this.#disposeGroup(rangeGroup),\n        });\n        liveRanges.forEach(liveRange => this.#liveRangesToGroups.set(liveRange, rangeGroup));\n        this.#idToGeometry.set(rangeGroup.id, rangeGroup);\n        if (visible) {\n            this.#visibleGeometry.add(rangeGroup.id);\n        }\n        if (TextRange.intersect(this.#visibleTextRange, rangeGroup.boundingRange)) {\n            this.#enqueueGeometryUpdateFor([rangeGroup], 'add');\n        }\n        return Result.success(rangeGroup);\n    }\n    pushTextChange(change, skipGeometryUpdate) {\n        using _ = tracer.startSpan('TextRangeGeometryManager.pushTextChange()', {\n            attributes: { change, skipGeometryUpdate },\n        });        this.#revision = { geometry: this.#revision.geometry, text: change.revision };\n        const { getChangedRanges, affectedRanges } = this.#textRangeManager.pushTextChange(change);\n        const affectedGroups = pipe(affectedRanges, map(r => this.#liveRangesToGroups.get(r)), filter(isNonNullable), dedupe, toArray);\n        const onScreenChangedGroups = pipe(getChangedRanges(), map(r => this.#liveRangesToGroups.get(r)), filter(isNonNullable), takeWhile(group => group.boundingRange.start < this.#visibleTextRange.end), dedupe, NonEmptyArray.from);\n        this.#logger.verbose('pushTextChange', {\n            change,\n            affectedGroups: affectedGroups.map(g => g.id),\n            onScreenChangedGroups: onScreenChangedGroups?.map(g => g.id),\n        });\n        // Calculate the geometry for the changed visible groups\n        if (onScreenChangedGroups && !skipGeometryUpdate) {\n            this.#enqueueGeometryUpdateFor(onScreenChangedGroups, 'textChange');\n        }\n        return {\n            affected: affectedGroups,\n            visibleChanged: onScreenChangedGroups ?? [],\n        };\n    }\n    pushDocumentGeometryChange(visibleTextRange, geometryRevision) {\n        using _ = tracer.startSpan('TextRangeGeometryManager.pushDocumentGeometryChange()', {\n            attributes: { visibleTextRange, geometryRevision },\n        });        this.#revision = { text: this.#revision.text, geometry: geometryRevision };\n        this.#visibleTextRange = TextRange.isCollapsed(visibleTextRange)\n            ? visibleTextRange\n            : TextRange.widen(visibleTextRange, this.#visibleTextRangePadding);\n        const onScreenGroups = pipe(this.#textRangeManager.getIntersecting(this.#visibleTextRange), map(r => this.#liveRangesToGroups.get(r)), filter(isNonNullable), dedupe, NonEmptyArray.from);\n        this.#logger.verbose('pushDocumentGeometryChange', {\n            visibleTextRange: TextRange.toString(this.#visibleTextRange),\n            onScreenGroups: onScreenGroups?.map(g => g.id),\n        });\n        // Calculate the geometry for the visible groups\n        this.#dirtyGeometry.clear();\n        if (onScreenGroups) {\n            this.#enqueueGeometryUpdateFor(onScreenGroups, 'documentGeometryChange');\n        }\n        return {\n            visible: onScreenGroups ?? [],\n        };\n    }\n    setVisibility(textRangeGroupIds, visible) {\n        const newVisibleGeometry = new Set();\n        for (const id of textRangeGroupIds) {\n            if (visible) {\n                if (!this.#visibleGeometry.has(id)) {\n                    this.#visibleGeometry.add(id);\n                    const geometry = this.#idToGeometry.get(id);\n                    if (geometry) {\n                        newVisibleGeometry.add(geometry);\n                    }\n                }\n            }\n            else {\n                this.#visibleGeometry.delete(id);\n            }\n        }\n        if (newVisibleGeometry.size > 0) {\n            void this.#enqueueGeometryUpdateFor(newVisibleGeometry, 'visibilityChange');\n        }\n    }\n    #disposeGroup(rangeGroup) {\n        rangeGroup.ranges.forEach(range => this.#liveRangesToGroups.delete(range));\n        this.#idToGeometry.delete(rangeGroup.id);\n        this.#visibleGeometry.delete(rangeGroup.id);\n        this.#dirtyGeometry.delete(rangeGroup);\n        dispose(rangeGroup);\n    }\n    #enqueueGeometryUpdateFor(groupsIterable, reason, force) {\n        const groups = toArray(groupsIterable);\n        this.#logger.verbose('queueGeometryUpdateFor', {\n            revision: TextAndGeometryRevision.toString(this.#revision),\n            groups: groups.map(g => g.toString()),\n            visibleTextRange: TextRange.toString(this.#visibleTextRange),\n            reason,\n        });\n        for (const group of groups) {\n            this.#dirtyGeometry.set(group, { revision: { ...this.#revision }, force });\n        }\n        if (groups.length > 0) {\n            this.#requestUpdateDirtyGeometry.next();\n        }\n    }\n    async #requestGeometryForDirtyGroups() {\n        if (!this.#geometryUpdateEnabled)\n            return;\n        const textAndGeometryRevision = { ...this.#revision };\n        const groups = toArray(pipe(this.#dirtyGeometry, \n        // Only request geometry for visible geometry or when the `force` flag is true\n        filter(([group, { force }]) => force === true ||\n            (this.#visibleGeometry.has(group.id) &&\n                TextRange.intersect(this.#visibleTextRange, group.boundingRange)))));\n        if (groups.length === 0)\n            return;\n        using _ = tracer.startSpan('TextRangeGeometryManager.#requestGeometryForGroups()', {\n            attributes: {\n                revision: textAndGeometryRevision,\n                groups: groups.map(([g, queuedRevision]) => ({\n                    id: g.id,\n                    ranges: g.ranges.length,\n                    queuedRevision,\n                })),\n            },\n        });        // Split the groups by the type of geometry needed, ignoring `lineBoundingBox` and mapping it to `rects`.\n        const separatedGroups = groupBy(groups, ([group]) => group.geometryKind === 'singleBoundingBox' ? 'boundingBox' : 'rects');\n        const groupsForRects = separatedGroups.get('rects') ?? [];\n        const groupsForBoundingBoxes = separatedGroups.get('boundingBox') ?? [];\n        const rangesForRects = groupsForRects.flatMap(([g]) => g.ranges);\n        const rangesForBoundingBoxes = groupsForBoundingBoxes.flatMap(([g]) => g.ranges);\n        this.#logger.verbose('geometry request', {\n            revision: TextAndGeometryRevision.toString(textAndGeometryRevision),\n            groups: groups.map(([g, queuedRevision]) => ({\n                id: g.id,\n                ranges: g.ranges.map(r => ({ start: r.start, end: r.end })),\n                queuedRevision,\n            })),\n        });\n        const defaultRectsResponse = {\n            rects: new Map(),\n            revision: textAndGeometryRevision,\n        };\n        const defaultBoundingRectsResponse = {\n            rects: new Map(),\n            revision: textAndGeometryRevision,\n        };\n        // Get rects and bounding boxes in parallel for all groups\n        const [rectsAndRevisions, boundingBoxesAndRevisions] = await Promise.all([\n            pipe(rangesForRects, NonEmptyArray.match({\n                nonEmpty: ranges => this.#getRectsWithRetry(ranges, defaultRectsResponse),\n                empty: () => Promise.resolve(defaultRectsResponse),\n            })),\n            pipe(rangesForBoundingBoxes, NonEmptyArray.match({\n                nonEmpty: ranges => this.#getBoundingRectsWithRetry(ranges, defaultBoundingRectsResponse),\n                empty: () => Promise.resolve(defaultBoundingRectsResponse),\n            })),\n        ]);\n        // Clear dirty geometry if the revision we received is >= than the revision requested for the dirty geometry\n        for (const [group] of groupsForRects) {\n            const dirtyGeometry = this.#dirtyGeometry.get(group);\n            if (dirtyGeometry &&\n                TextAndGeometryRevision.isGreaterOrEqual(rectsAndRevisions.revision, dirtyGeometry.revision)) {\n                this.#dirtyGeometry.delete(group);\n            }\n        }\n        // Clear dirty geometry if the revision we received is >= than the revision requested for the dirty geometry\n        for (const [group] of groupsForBoundingBoxes) {\n            const dirtyGeometry = this.#dirtyGeometry.get(group);\n            if (dirtyGeometry &&\n                TextAndGeometryRevision.isGreaterOrEqual(boundingBoxesAndRevisions.revision, dirtyGeometry.revision)) {\n                this.#dirtyGeometry.delete(group);\n            }\n        }\n        // Associate rects to groups and call resolve on each group\n        groupsForRects.forEach(([group]) => group.resolveRects(group.ranges.map(range => rectsAndRevisions.rects.get(range.id) ?? []), rectsAndRevisions.revision));\n        // Associate bounding boxes to groups and call resolve on each group\n        groupsForBoundingBoxes.forEach(([group]) => group.resolveRects(group.ranges.map(range => [boundingBoxesAndRevisions.rects.get(range.id) ?? []].flat()), boundingBoxesAndRevisions.revision));\n        this.#emitMetrics?.({\n            rangeCount: groups.flatMap(([g]) => g.ranges).length,\n            rectCount: Array.from(rectsAndRevisions.rects.values()).flat().length +\n                boundingBoxesAndRevisions.rects.size,\n        });\n        this.#logger.verbose('geometry response', {\n            revision: TextAndGeometryRevision.toString(textAndGeometryRevision),\n            groups: groups.map(([g]) => g.id),\n            rectsAndRevisions,\n            boundingBoxesAndRevisions,\n        });\n    }\n    [Symbol.dispose]() {\n        this.#disposables.dispose();\n    }\n    #getRectsWithRetry(ranges, defaultValue) {\n        return pipe(AsyncResult.retry(() => pipe(this.#getRects(new Map(pipe(ranges, map(r => [r.id, { start: r.start, end: r.end }])))), AsyncResult.mapError(sideEffect(error => this.#logger.error('Unexpected error getting rects', error)))), {\n            maxRetries: 3,\n            delayMs: () => 1000,\n        }), AsyncResult.match({\n            success: identity,\n            failure: error => {\n                this.#logger.error('Unexpected error getting rects - reached max retries, returning empty rects', error);\n                return defaultValue;\n            },\n        }));\n    }\n    #getBoundingRectsWithRetry(ranges, defaultValue) {\n        return pipe(AsyncResult.retry(() => pipe(this.#getBoundingRects(new Map(pipe(ranges, map(r => [r.id, { start: r.start, end: r.end }])))), AsyncResult.mapError(sideEffect(error => this.#logger.error('Unexpected error getting bounding rects', error)))), {\n            maxRetries: 3,\n            delayMs: () => 1000,\n        }), AsyncResult.match({\n            success: identity,\n            failure: error => {\n                this.#logger.error('Unexpected error getting bounding rects - reached max retries, returning empty rects', error);\n                return defaultValue;\n            },\n        }));\n    }\n}\n/** @internal */\nclass DefaultLiveTextRangeGroupWithGeometry {\n    #disposables = new DisposableStack();\n    #metadata;\n    #geometryKind;\n    #ranges;\n    #idSequence = new IdSequence();\n    #enqueueGetRects;\n    #onDispose;\n    #rects = new Rx.BehaviorSubject(null);\n    id;\n    constructor(options) {\n        this.id = options.id ?? this.#idSequence.next();\n        this.#ranges = options.ranges;\n        this.#metadata = options.metadata;\n        this.#geometryKind = options.geometryKind;\n        this.#onDispose = options.onDispose;\n        this.#enqueueGetRects = options.enqueueGetRects;\n        this.#disposables.defer(() => {\n            this.#ranges.forEach(dispose);\n            this.#onDispose();\n        });\n    }\n    get geometryKind() {\n        return this.#geometryKind;\n    }\n    get metadata() {\n        return this.#metadata;\n    }\n    get revision() {\n        return this.#ranges[0].revision;\n    }\n    get textAndGeometryRevision() {\n        return this.#rects.getValue()?.revision ?? null;\n    }\n    get ranges() {\n        return this.#ranges;\n    }\n    get boundingRange() {\n        return TextRange.union(...this.#ranges);\n    }\n    getRects(minimumRevision) {\n        const rectsState = this.#rects.getValue();\n        // In most cases, the manager should already have scheduled an update\n        // for these rectangles if they are onscreen and:\n        // - the document geometry has changed\n        // - the text has changed\n        // - the visibility has changed\n        // However, for robustness, and if offscreen rectangles are requested, we want\n        // to make sure that the geometry gets requested. The geometry will batch and dedupe requests\n        // to avoid requesting the same geometry for the same revision.\n        if (!rectsState || TextAndGeometryRevision.isGreater(minimumRevision, rectsState.revision)) {\n            this.#enqueueGetRects(minimumRevision);\n        }\n        return AsyncResult.fromPromise(Rx.firstValueFrom(pipe(this.#rects, Rx.map(rectsAndRevision => rectsAndRevision &&\n            TextAndGeometryRevision.isGreaterOrEqual(rectsAndRevision.revision, minimumRevision)\n            ? rectsAndRevision\n            : null), Rx.filter(isNonNullable))));\n    }\n    toString() {\n        const ranges = this.ranges.map(r => TextRange.toString(r)).join(', ');\n        const revision = this.#rects.getValue()?.revision;\n        return `TextRangeGroupGeometry({ id: ${this.id}, ranges: [${ranges}], revision: ${revision ? TextAndGeometryRevision.toString(revision) : null} })`;\n    }\n    resolveRects(rects, revision) {\n        const rectsAndRevision = this.#rects.getValue();\n        if (\n        // Accept rectangles if we don't have any yet\n        !rectsAndRevision ||\n            // Accept rectangles if they are for a revision greater than the current revision we have.\n            TextAndGeometryRevision.isGreater(revision, rectsAndRevision.revision)) {\n            this.#rects.next({\n                rects: this.#geometryKind === 'lineBoundingBox' ? rects.map(getLineBoundingBoxes) : rects,\n                revision,\n            });\n        }\n    }\n    [Symbol.dispose]() {\n        this.#disposables.dispose();\n    }\n}\n\nexport { TextRangeGeometryManager };\n//# sourceMappingURL=TextRangeGeometryManager-DwDHZb.mjs.map\n","import { logger } from '@grammarly/util-logging'\n\nexport type CanvasInspectorMessage =\n  | {\n      readonly kind: 'createElement'\n      readonly tagName: string\n      readonly id: string\n      readonly parentId: string | null\n    }\n  | {\n      readonly kind: 'removeElement'\n      readonly id: string\n    }\n  | {\n      readonly kind: 'updateAttributes'\n      readonly id: string\n      readonly attributes: { readonly [key: string]: string | null }\n    }\n  | {\n      readonly kind: 'removeAllChildren'\n      readonly id: string\n    }\n\n/**\n * Canvas inspector creates DOM elements and manipulates them\n * to visualize the canvas state.\n */\nexport interface CanvasInspector {\n  (message: CanvasInspectorMessage): void\n}\n\nexport function createPrefixedCanvasInspector(\n  prefix: string,\n  inspector: CanvasInspector,\n): CanvasInspector {\n  return message => {\n    if (message.kind === 'createElement') {\n      return inspector({\n        ...message,\n        id: `${prefix}-${message.id}`,\n        parentId: message.parentId === null ? null : `${prefix}-${message.parentId}`,\n      })\n    } else {\n      return inspector({\n        ...message,\n        id: `${prefix}-${message.id}`,\n      })\n    }\n  }\n}\n\nexport function createScopedCanvasInspector(\n  parentId: string,\n  inspector: CanvasInspector,\n): CanvasInspector {\n  return message => {\n    if (message.kind === 'createElement') {\n      return inspector({\n        ...message,\n        parentId: message.parentId || parentId,\n      })\n    } else {\n      return inspector(message)\n    }\n  }\n}\n\nexport function transformObject<R = unknown>(\n  object: object,\n  key: (key: string) => string,\n  value: (value: unknown) => R = value => value as R,\n): Record<string, R> {\n  const result: Record<string, R> = {}\n  for (const [k, v] of Object.entries(object)) {\n    result[key(k)] = value(v)\n  }\n  return result\n}\n\nfunction getElementById(id: string): HTMLElement | null {\n  const element: HTMLElement | null = document.getElementById(id)\n  if (element === null) {\n    logger.warn(`Element with id ${id} not found.`)\n  }\n\n  return element\n}\n\nfunction getInspectorContainer(): HTMLElement {\n  const existing = document.getElementById('canvas-inspector')\n  if (existing !== null) {\n    return existing\n  }\n  const element = document.createElement('canvas-inspector')\n  element.setAttribute('info', 'Remove display: none; to show the inspector.')\n  element.setAttribute('style', 'pointer-events: none; display: none;')\n  element.id = 'canvas-inspector'\n  document.body.appendChild(element)\n\n  return element\n}\n\nexport function handleCanvasInspectorMessage(\n  message: CanvasInspectorMessage,\n  container: HTMLElement = getInspectorContainer(),\n): void {\n  switch (message.kind) {\n    case 'createElement': {\n      const element = document.createElement(message.tagName)\n\n      element.id = message.id\n      if (message.parentId) {\n        getElementById(message.parentId)?.appendChild(element)\n      } else {\n        container.appendChild(element)\n      }\n      break\n    }\n\n    case 'removeElement': {\n      getElementById(message.id)?.remove()\n      break\n    }\n\n    case 'updateAttributes': {\n      const element = getElementById(message.id)\n      if (element !== null) {\n        for (const [key, value] of Object.entries(message.attributes)) {\n          if (value === null) {\n            element.removeAttribute(key)\n          } else {\n            element.setAttribute(key, value)\n          }\n        }\n      }\n      break\n    }\n\n    case 'removeAllChildren': {\n      const element = getElementById(message.id)\n      if (element !== null) {\n        element.innerHTML = ''\n      }\n      break\n    }\n  }\n}\n","import { UnreachableCaseError } from '@grammarly/util-error'\n\nexport interface Animation<Meta = undefined> {\n  readonly kind: 'fadeIn' | 'fadeOut'\n  readonly startTime: number\n  readonly duration: number\n  readonly metadata: Meta\n  // eslint-disable-next-line functional/prefer-readonly-type\n  running: boolean\n}\n\nexport function stepAnimation(animation: Animation<unknown>, onDone?: () => void) {\n  if (animation.kind === 'fadeIn') {\n    const alpha = interpolate(animation.startTime, performance.now(), animation.duration)\n    if (alpha === 1) {\n      animation.running = false\n      onDone?.()\n    }\n    return { alpha, running: animation.running }\n  } else if (animation.kind === 'fadeOut') {\n    const alpha = 1 - interpolate(animation.startTime, performance.now(), animation.duration)\n    if (alpha === 0) {\n      animation.running = false\n      onDone?.()\n    }\n    return { alpha, running: animation.running }\n  } else {\n    throw new UnreachableCaseError(animation.kind)\n  }\n}\n\nfunction interpolate(start: number, end: number, duration: number) {\n  return Math.min(1, Math.max((end - start) / duration, 0))\n}\n","import { identity, pipe } from '@grammarly/util-function'\nimport { ContentRect, Rect, type TextAndGeometryRevision } from '@grammarly/util-geometry'\nimport { filter, flatMap, toArray, toSet } from '@grammarly/util-iterable'\nimport { round } from '@grammarly/util-math'\nimport { Rx } from '@grammarly/util-reactive'\nimport { tracer } from '@grammarly/util-tracing'\nimport RBush, { type BBox } from 'rbush'\nimport type { OverSamplingFactor } from './CanvasTextDecorationManager'\nimport { type Animation, stepAnimation } from './animation'\n\n/**\n * Return type for `CanvasDrawable.render()`.\n * `render()` is a generator function that can yield between animation steps.\n * As long as the generator is not done, `next()` will be called in successive animation frames.\n */\nexport type RenderGenerator = Generator<void, void, void>\n\nexport interface CanvasDrawable {\n  /** Bounding rect of the drawable, recalculated on layout */\n  readonly boundingRect: ContentRect\n  /** z-index of the drawable */\n  readonly zIndex: number\n  /** Opaque rects do not show content rendered behind */\n  readonly opaqueRects: readonly ContentRect[]\n  /** List of rectangles that are visible */\n  readonly visibleRects: readonly ContentRect[]\n  /** Recalculate the layout of the drawable for the provided revision or greater */\n  layout(minimumRevision: TextAndGeometryRevision): Promise<ContentRect>\n  /** Render the drawable. For animations, yield on every step until the animation is done */\n  render(context: OffscreenCanvasRenderingContext2D): RenderGenerator\n}\n\nexport interface AddOptions<TDrawable extends CanvasDrawable> {\n  readonly drawable: TDrawable\n  readonly visible: boolean\n  readonly onscreen: boolean\n}\n\nexport interface CanvasRenderer<TDrawable extends CanvasDrawable> {\n  /** Add new drawables */\n  add(drawables: Iterable<AddOptions<TDrawable>>): void\n  /** Remove drawables */\n  remove(drawables: Iterable<TDrawable>): void\n  /** Request a redraw of the given drawables. `drawable.layout()` will not be called. */\n  requestRender(drawables: Iterable<TDrawable>): void\n  /** Request a layout and redraw the given drawables. */\n  requestLayout(drawables: Iterable<TDrawable>, revision: TextAndGeometryRevision): void\n  /**\n   * Sets the viewport dimensions along with all drawables intersecting with the viewport (and maybe more).\n   * For each of the drawable, `drawable.layout()` will be called to wait for fresh rectangles.\n   */\n  setViewport(\n    onscreenDrawables: Iterable<TDrawable>,\n    viewport: ContentRect,\n    devicePixelRatio: number,\n    revision: TextAndGeometryRevision,\n  ): void\n  /** Changes the visibility of the given drawables */\n  setVisibility(drawable: Iterable<TDrawable>, visible: boolean): void\n  /** Show all visible drawables - does not mutate the visibility of drawables */\n  showAllVisible(): void\n  /** Hide all visible drawables - does not mutate the visibility of drawables */\n  hideAllVisible(): void\n}\n\nexport interface CanvasRendererMetrics<TDrawable extends CanvasDrawable> {\n  /** Number of drawables rendered during the last render loop */\n  readonly drawablesRenderedOnLastRenderLoop: number\n  /** Number of drawables that are currently visible on-screen and rendered */\n  readonly renderedVisibleOnscreenDrawables: ReadonlySet<TDrawable>\n  /** Number of drawables that are not marked as hidden (but are not necessarily rendered) */\n  readonly visibleDrawables: ReadonlySet<TDrawable>\n  /** Total number of drawables currently added to the renderer (may be hidden or visible, rendered or not) */\n  readonly allDrawables: ReadonlySet<TDrawable>\n}\n\nexport interface DefaultCanvasRendererOptions<TDrawable extends CanvasDrawable> {\n  readonly canvas: OffscreenCanvas\n  readonly context: OffscreenCanvasRenderingContext2D\n  readonly viewportGeometry: ContentRect\n  readonly devicePixelRatio: number\n  readonly oversamplingFactor: OverSamplingFactor\n  emitRenderMetrics(metrics: CanvasRendererMetrics<TDrawable>): void\n}\n\nexport class DefaultCanvasRenderer<TDrawable extends CanvasDrawable>\n  implements CanvasRenderer<TDrawable>, Disposable\n{\n  // For debugging\n  readonly #drawDirtyRect = false\n  readonly #drawViewport = false\n\n  readonly #disposables = new DisposableStack()\n  readonly #canvas: OffscreenCanvas\n  readonly #ctx: OffscreenCanvasRenderingContext2D\n  readonly #oversamplingFactor: OverSamplingFactor\n  readonly #renderGenerators = new Map<TDrawable, RenderGenerator>()\n  readonly #drawables = new Set<TDrawable>()\n  readonly #onscreen = new Set<TDrawable>()\n  readonly #hidden = new Set<TDrawable>()\n  readonly #needsLayout = new Set<TDrawable>()\n  readonly #needsRender = new Set<TDrawable>()\n  readonly #toRemove = new Set<TDrawable>()\n\n  // When false, all onscreen drawables will be re-rendered anytime `render()` is called\n  // When true, only drawables that are dirty or that intersect a dirty rect will be re-rendered.\n  readonly #useDirtyRects = true\n\n  readonly #rtree = new RTree<TDrawable>({ returnAllDrawables: !this.#useDirtyRects })\n  readonly #emitRenderMetrics: (metrics: CanvasRendererMetrics<TDrawable>) => void\n\n  readonly #renderRequest = new Rx.Subject<{\n    readonly reason?: string\n    readonly immediate?: boolean\n  }>()\n\n  #viewportGeometry: ContentRect\n  #devicePixelRatio: number\n  #allHidden = false\n  /** Animation used to fade-in/fade-out when all decorations are hidden/shown */\n  #globalAlphaAnimation: Animation | undefined = undefined\n  #revision: TextAndGeometryRevision | null = null\n\n  constructor(options: DefaultCanvasRendererOptions<TDrawable>) {\n    this.#canvas = options.canvas\n    this.#ctx = options.context\n    this.#viewportGeometry = options.viewportGeometry\n    this.#devicePixelRatio = options.devicePixelRatio\n    this.#oversamplingFactor = options.oversamplingFactor\n    this.#emitRenderMetrics = options.emitRenderMetrics\n\n    let immediateRenderRequested = false\n    const renderReasons: string[] = []\n\n    this.#disposables.use(\n      pipe(\n        this.#renderRequest,\n        Rx.tap(request => {\n          if (request.reason) {\n            renderReasons.push(request.reason)\n          }\n          if (request.immediate) {\n            immediateRenderRequested = true\n          }\n        }),\n        Rx.exhaustMapWithTrailing(() => {\n          const immediate = immediateRenderRequested\n          const reasons = [...renderReasons]\n          immediateRenderRequested = false\n          renderReasons.length = 0\n\n          return pipe(\n            Rx.of(this.#revision),\n            Rx.observeOn(immediate ? Rx.asapScheduler : Rx.animationFrameScheduler),\n            Rx.mergeMap(revision =>\n              revision ? this.#render(revision, [...new Set(reasons)].join(', ')) : Rx.EMPTY,\n            ),\n          )\n        }),\n        Rx.subscribe(needsRender => {\n          if (needsRender) {\n            this.#renderRequest.next({ reason: 'animation' })\n          }\n        }),\n      ),\n    )\n  }\n\n  add(drawables: Iterable<AddOptions<TDrawable>>) {\n    for (const { drawable, visible, onscreen } of drawables) {\n      this.#drawables.add(drawable)\n      if (onscreen) {\n        this.#needsLayout.add(drawable)\n        this.#onscreen.add(drawable)\n      }\n      if (!visible) {\n        this.#hidden.add(drawable)\n      }\n    }\n    this.#renderRequest.next({ reason: 'add-drawable' })\n  }\n\n  remove(drawables: Iterable<TDrawable>) {\n    for (const drawable of drawables) {\n      this.#needsLayout.delete(drawable)\n      this.#needsRender.delete(drawable)\n      this.#onscreen.delete(drawable)\n      this.#drawables.delete(drawable)\n      this.#rtree.remove(drawable)\n      this.#toRemove.add(drawable)\n    }\n    this.#renderRequest.next({ reason: 'remove-drawable' })\n  }\n\n  requestRender(drawables: Iterable<TDrawable>) {\n    for (const drawable of drawables) {\n      this.#needsRender.add(drawable)\n    }\n    this.#renderRequest.next({ reason: 'request-render' })\n  }\n\n  requestLayout(drawables: Iterable<TDrawable>, revision: TextAndGeometryRevision) {\n    this.#revision = revision\n    for (const drawable of drawables) {\n      this.#needsLayout.add(drawable)\n    }\n\n    this.#renderRequest.next({ reason: 'request-layout', immediate: true })\n  }\n\n  setViewport(\n    onscreenDrawables: Iterable<TDrawable>,\n    viewport: ContentRect,\n    devicePixelRatio: number,\n    revision: TextAndGeometryRevision,\n  ) {\n    this.#revision = revision\n    this.#viewportGeometry = viewport\n    this.#devicePixelRatio = devicePixelRatio\n    this.#onscreen.clear()\n    this.#needsLayout.clear()\n    this.#rtree.clear()\n\n    for (const drawable of onscreenDrawables) {\n      this.#needsLayout.add(drawable)\n      this.#onscreen.add(drawable)\n    }\n\n    this.#renderRequest.next({ reason: 'viewport-change', immediate: true })\n  }\n\n  setVisibility(drawables: Iterable<TDrawable>, visible: boolean) {\n    for (const drawable of drawables) {\n      if (visible) {\n        const removed = this.#hidden.delete(drawable)\n        if (removed) {\n          this.#needsRender.add(drawable)\n        }\n      } else {\n        if (!this.#hidden.has(drawable)) {\n          this.#hidden.add(drawable)\n          this.#needsRender.add(drawable)\n        }\n      }\n    }\n    this.#renderRequest.next({ reason: 'set-visibility' })\n  }\n\n  showAllVisible() {\n    if (!this.#allHidden) return\n    this.#allHidden = false\n    this.#globalAlphaAnimation = {\n      kind: 'fadeIn',\n      startTime: performance.now(),\n      duration: 300,\n      running: true,\n      metadata: undefined,\n    }\n\n    for (const drawable of this.#onscreen) {\n      this.#needsRender.add(drawable)\n    }\n\n    this.#renderRequest.next({ reason: 'show-all-visible' })\n  }\n\n  hideAllVisible() {\n    if (this.#allHidden) return\n    this.#allHidden = true\n    // We don't animate hide-all, if we would, we would risk showing stale\n    // decorations after a scroll while the fade-out animation is running.\n    this.#globalAlphaAnimation = undefined\n    this.#renderRequest.next({ reason: 'hide-all-visible' })\n  }\n\n  /**\n   * Runs render for a given text and geometry revision and returns `true` if\n   * another render should be queued.\n   */\n  async #render(minimumRevision: TextAndGeometryRevision, reason?: string): Promise<boolean> {\n    using _ = tracer.startSpan('CanvasRenderer.#render()', {\n      attributes: { reason, minimumRevision },\n    })\n\n    if (this.#allHidden && !this.#globalAlphaAnimation?.running) {\n      this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height)\n      const metrics = {\n        drawablesRenderedOnLastRenderLoop: 0,\n        renderedVisibleOnscreenDrawables: new Set(),\n        visibleDrawables: this.#drawables.difference(this.#hidden),\n        allDrawables: new Set(this.#drawables),\n      } satisfies CanvasRendererMetrics<TDrawable>\n      queueMicrotask(() => this.#emitRenderMetrics(metrics))\n      return false\n    }\n\n    // Calculate the dirty rect for the geometry that needs to be rendered\n    // This will call and await drawable.layout() on all drawables that are visible, on-screen\n    // and need layout calculation.\n    // The dirty rectangle is the union of all new and old rects from the drawables that need to be rendered.\n    let dirtyRect =\n      // When animating a global fade-out, we set the dirty rect to all viewport and skip layout\n      this.#globalAlphaAnimation?.running && this.#globalAlphaAnimation.kind === 'fadeOut'\n        ? this.#viewportGeometry\n        : await this.#calculateDirtyRectForRender(minimumRevision)\n\n    // Set actual size in memory (scaled to account for extra pixel density and quality factor).\n    const scale = this.#devicePixelRatio * this.#oversamplingFactor\n    const width = round(this.#viewportGeometry.width * scale)\n    const height = round(this.#viewportGeometry.height * scale)\n\n    if (this.#canvas.width !== width || this.#canvas.height !== height) {\n      this.#canvas.width = width\n      this.#canvas.height = height\n      // If the canvas was resized, the dirty rect now matches the viewport.\n      dirtyRect = this.#viewportGeometry\n    }\n\n    // If we are animating a global fade-in, we set the dirty rect to all viewport\n    if (this.#globalAlphaAnimation?.running && this.#globalAlphaAnimation.kind === 'fadeIn') {\n      dirtyRect = this.#viewportGeometry\n    }\n\n    if (!dirtyRect) return false\n\n    this.#ctx.save()\n    this.#ctx.scale(scale, scale)\n    this.#ctx.translate(-round(this.#viewportGeometry.x), -round(this.#viewportGeometry.y))\n    this.#ctx.globalCompositeOperation = 'source-over'\n    const alpha = this.#globalAlphaAnimation ? stepAnimation(this.#globalAlphaAnimation).alpha : 1\n    this.#ctx.globalAlpha = alpha\n\n    const drawables = this.#getDrawablesToRender(dirtyRect)\n    const hasAnimatingDrawables = this.#clearDirtyRectAndRenderDrawables(dirtyRect, drawables)\n\n    if (this.#drawViewport) {\n      this.#ctx.strokeStyle = 'blue'\n      this.#ctx.strokeRect(\n        this.#viewportGeometry.x,\n        this.#viewportGeometry.y,\n        Math.floor(this.#viewportGeometry.width),\n        Math.floor(this.#viewportGeometry.height),\n      )\n    }\n\n    this.#ctx.restore()\n\n    const metrics = {\n      drawablesRenderedOnLastRenderLoop: drawables.size,\n      renderedVisibleOnscreenDrawables: pipe(\n        this.#onscreen.difference(this.#hidden),\n        // Making sure onscreen drawables are contained within the viewport.\n        filter(drawable => Rect.intersect(this.#viewportGeometry, drawable.boundingRect)),\n        // Further filter to only include decorations with visible segments in the viewport\n        filter(drawable =>\n          drawable.visibleRects.some(rect => Rect.intersect(this.#viewportGeometry, rect)),\n        ),\n        toSet,\n      ),\n      visibleDrawables: this.#drawables.difference(this.#hidden),\n      allDrawables: new Set(this.#drawables),\n    } satisfies CanvasRendererMetrics<TDrawable>\n    queueMicrotask(() => this.#emitRenderMetrics(metrics))\n\n    return hasAnimatingDrawables || this.#globalAlphaAnimation?.running === true\n  }\n\n  #getDrawablesToRender(dirtyRect: ContentRect) {\n    // Get all visible drawables that intersect the dirty rect.\n    return pipe(\n      (Rect.equals(dirtyRect, this.#viewportGeometry)\n        ? this.#onscreen\n        : this.#rtree.getIntersections(dirtyRect)\n      ).difference(this.#hidden),\n      // Make sure everything is clipped to the viewport\n      filter(drawable => Rect.intersect(this.#viewportGeometry, drawable.boundingRect)),\n      toSet,\n    )\n  }\n\n  #clearDirtyRectAndRenderDrawables(dirtyRect: ContentRect, drawables: Set<TDrawable>) {\n    // Clear the dirty rect\n    this.#ctx.clearRect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height)\n\n    // For debugging\n    if (this.#drawDirtyRect) {\n      this.#ctx.strokeStyle = 'red'\n      this.#ctx.strokeRect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height)\n    }\n\n    // Create a clip rect around the dirty rect to make sure we do not render anything outside of this rect\n    this.#ctx.rect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height)\n    this.#ctx.clip()\n\n    // Render all drawables intersecting the cleared and clipped dirty rect\n    return this.#renderDrawables(drawables)\n  }\n\n  #renderDrawables(drawables: Set<TDrawable>) {\n    // We must preserve the state of #renderGenerators for animations\n    // So we sync them with `drawables` by adding missing ones, and removing obsolete ones.\n\n    // Remove obsolete render generators\n    for (const drawable of this.#renderGenerators.keys()) {\n      if (!drawables.has(drawable)) {\n        this.#renderGenerators.delete(drawable)\n      }\n    }\n    // Add missing render generators\n    for (const drawable of drawables) {\n      if (!this.#renderGenerators.has(drawable)) {\n        this.#renderGenerators.set(drawable, drawable.render(this.#ctx))\n      }\n    }\n\n    // Render all drawables intersecting the clip rect\n    let animatingDrawables = this.#renderGenerators.size\n    const sortedGenerators = toArray(this.#renderGenerators.entries()).sort(\n      (a, b) => a[0].zIndex - b[0].zIndex,\n    )\n\n    // Iterate over all render generators intersecting the dirty rect and call `next()` on them to trigger a render.\n    for (const [drawable, renderGenerator] of sortedGenerators) {\n      for (const rect of drawable.opaqueRects) {\n        this.#ctx.clearRect(rect.x, rect.y, rect.width, rect.height)\n      }\n      const { done } = renderGenerator.next()\n      if (done) {\n        animatingDrawables--\n        this.#needsRender.delete(drawable)\n        // We need to re-create a render generator if an animation finishes\n        // so that the segment will be rendered again on the next iteration if not all animations are done.\n        this.#renderGenerators.set(drawable, drawable.render(this.#ctx))\n      } else {\n        this.#needsRender.add(drawable)\n      }\n    }\n\n    return animatingDrawables > 0\n  }\n\n  async #calculateDirtyRectForRender(\n    revision: TextAndGeometryRevision,\n  ): Promise<ContentRect | null> {\n    const dirtyRects: ContentRect[] = []\n\n    // Add the rects for drawables that need to have have fresh rects recalculated\n    if (this.#needsLayout.size > 0) {\n      const rect = await this.#layoutVisibleOnscreenDrawables(revision)\n      if (rect) dirtyRects.push(rect)\n    }\n\n    // Add the rects for drawables that need redrawing and are on screen\n    for (const drawable of this.#needsRender) {\n      if (\n        !Rect.isCollapsed(drawable.boundingRect) &&\n        Rect.intersect(this.#viewportGeometry, drawable.boundingRect)\n      ) {\n        dirtyRects.push(drawable.boundingRect)\n        this.#needsRender.delete(drawable)\n      }\n    }\n\n    // Add the rects for drawables that need to be removed and were on screen\n    for (const drawable of this.#toRemove) {\n      this.#toRemove.delete(drawable)\n      if (\n        !Rect.isCollapsed(drawable.boundingRect) &&\n        Rect.intersect(this.#viewportGeometry, drawable.boundingRect)\n      ) {\n        dirtyRects.push(drawable.boundingRect)\n      }\n    }\n\n    // NOTE: This 1px padding is here for safety to increase the dirty rects dimensions\n    // and avoid potential rendering artifacts on decoration removal.\n    const dirtyRect = pipe(dirtyRects.map(Rect.addPadding(1)), Rect.unionOrElse(null))\n\n    // Make sure the dirty rect is not bigger than the viewport and not collapsed\n    return dirtyRect && !Rect.isCollapsed(dirtyRect)\n      ? Rect.intersection(dirtyRect, this.#viewportGeometry)\n      : null\n  }\n\n  async #layoutVisibleOnscreenDrawables(\n    minimumRevision: TextAndGeometryRevision,\n  ): Promise<ContentRect | null> {\n    if (this.#needsLayout.size === 0) return null\n\n    const oldAndNewRects: Array<readonly [old: ContentRect, new: Promise<ContentRect>]> = []\n    const visibleOnscreen = new Set<TDrawable>()\n\n    for (const drawable of this.#needsLayout) {\n      // Skip if not visible\n      if (this.#hidden.has(drawable) || !this.#onscreen.has(drawable)) continue\n\n      const oldRect = drawable.boundingRect\n      oldAndNewRects.push([oldRect, drawable.layout(minimumRevision)])\n      visibleOnscreen.add(drawable)\n      this.#needsLayout.delete(drawable)\n      this.#rtree.remove(drawable)\n    }\n\n    // Wait for layout to finish before adding to the RTree so each boundingRect gets recalculated\n    const oldAndNewRectsResolved = await Promise.all(\n      oldAndNewRects.map(async ([oldRect, newRect]) => [oldRect, await newRect]),\n    )\n    this.#rtree.load(visibleOnscreen)\n\n    // The dirty rect (area that needs re-rendering)\n    // is the union of all \"old\" and \"new\" boundingRect for each drawable\n    return pipe(\n      oldAndNewRectsResolved,\n      flatMap(identity),\n      filter(rect => !Rect.isCollapsed(rect)),\n      toArray,\n      Rect.unionOrElse(null),\n    )\n  }\n\n  [Symbol.dispose]() {\n    this.#disposables.dispose()\n  }\n}\n\n/** @internal */\nclass RTree<TDrawable extends CanvasDrawable> extends RBush<TDrawable> {\n  private readonly _drawables = new Set<TDrawable>()\n  private readonly _returnAllDrawables: boolean\n\n  constructor(options: { readonly returnAllDrawables: boolean }) {\n    super()\n    this._returnAllDrawables = options.returnAllDrawables ?? false\n  }\n\n  override toBBox(drawable: TDrawable): BBox {\n    const rect = drawable.boundingRect\n    return { minX: rect.x, minY: rect.y, maxX: rect.x + rect.width, maxY: rect.y + rect.height }\n  }\n\n  override compareMinX(a: TDrawable, b: TDrawable): number {\n    const aRect = a.boundingRect\n    const bRect = b.boundingRect\n    return aRect.x - bRect.x\n  }\n\n  override compareMinY(a: TDrawable, b: TDrawable): number {\n    const aRect = a.boundingRect\n    const bRect = b.boundingRect\n    return aRect.y - bRect.y\n  }\n\n  override load(drawablesIterable: Iterable<TDrawable>): RBush<TDrawable> {\n    const drawables = toSet(drawablesIterable)\n    drawables.forEach(drawable => this._drawables.add(drawable))\n    if (this._returnAllDrawables) return this\n    return super.load(toArray(drawables))\n  }\n\n  override insert(item: TDrawable): RBush<TDrawable> {\n    this._drawables.add(item)\n    return super.insert(item)\n  }\n\n  override remove(drawable: TDrawable): RBush<TDrawable> {\n    this._drawables.delete(drawable)\n    if (this._returnAllDrawables) return this\n    return super.remove(drawable)\n  }\n\n  override clear(): RBush<TDrawable> {\n    // Clear is called in RBush constructor when this._rects isn't defined yet, hence the `?`\n    this._drawables?.clear()\n    if (this._returnAllDrawables) return this\n    return super.clear()\n  }\n\n  getIntersections(rect: ContentRect): Set<TDrawable> {\n    return this._returnAllDrawables\n      ? this._drawables\n      : new Set(\n          super.search({\n            minX: rect.x,\n            minY: rect.y,\n            maxX: rect.x + rect.width,\n            maxY: rect.y + rect.height,\n          }),\n        )\n  }\n}\n","import { pipe } from '@grammarly/util-function'\nimport {\n  ContentRect,\n  getLineBoundingBoxes,\n  InteractiveGeometryManager,\n  Rect,\n  type TextAndGeometryRevision,\n} from '@grammarly/util-geometry'\nimport { filter, flatMap, map, toArray, zip } from '@grammarly/util-iterable'\nimport { round } from '@grammarly/util-math'\nimport { AsyncResult } from '@grammarly/util-result'\nimport { logger } from '@grammarly/util-logging'\nimport { type LiveTextRangeGroupWithGeometry } from '@grammarly/util-text-range-geometry'\nimport { stepAnimation, type Animation } from './animation'\nimport { transformObject, type CanvasInspector } from './CanvasInspector'\nimport type { CanvasDrawable } from './CanvasRenderer'\nimport type {\n  BackgroundRenderOptions,\n  TextDecorationId,\n  TextDecorationSegmentId,\n  UnderlineRenderOptions,\n} from './TextDecoration'\n\nconst DEFAULT_UNDERLINE_ALIGNMENT = 'outside'\nconst DEFAULT_UNDERLINE_THICKNESS = 2\n\n/**\n * Segment id with decoration id\n */\nexport type ComposedSegmentId = string & { readonly __ComposedSegmentId: unique symbol }\n\nexport function createComposedSegmentId(\n  decorationId: TextDecorationId,\n  segmentId: TextDecorationSegmentId,\n): ComposedSegmentId {\n  return JSON.stringify([decorationId, segmentId]) as ComposedSegmentId\n}\n\nexport function extractDecorationAndSegmentId(segmentIdentifier: ComposedSegmentId) {\n  const [decorationId, segmentId] = JSON.parse(segmentIdentifier)\n  return {\n    decorationId: decorationId as TextDecorationId,\n    segmentId: segmentId as TextDecorationSegmentId,\n  }\n}\n\nexport interface SegmentPatchOptions {\n  readonly underline?: UnderlineRenderOptions | null\n  readonly background?: BackgroundRenderOptions | null\n  readonly interactive?: boolean\n}\n\ninterface Segment {\n  readonly id: TextDecorationSegmentId\n  /** Whether this text range reports hover and click events */\n  readonly interactive?: boolean\n  /** Visual metadata for the underline, or `undefined` for no underline */\n  readonly underline?: UnderlineRenderOptions\n  /** Visual metadata for the background, or `undefined` for no background */\n  readonly background?: BackgroundRenderOptions\n}\n\nexport interface SegmentAndRects extends Segment {\n  /** Rectangles that were adjusted to bound the underline */\n  readonly rects: readonly ContentRect[]\n  /** Raw, non-adjusted rectangles */\n  readonly rawRects: readonly ContentRect[]\n}\n\ntype BackgroundAnimation = Animation<{ readonly background: BackgroundRenderOptions }>\ntype UnderlineAnimation = Animation<{ readonly underline: UnderlineRenderOptions }>\n\ninterface SegmentInternal extends SegmentAndRects {\n  readonly backgroundAnimation?: BackgroundAnimation\n  readonly underlineAnimation?: UnderlineAnimation\n}\n\nexport interface CanvasDecorationCreateOptions {\n  readonly decorationId: TextDecorationId\n  readonly rangesGroup: LiveTextRangeGroupWithGeometry<unknown, unknown>\n  readonly segments: readonly Segment[]\n  readonly interactiveGeometryManager: InteractiveGeometryManager<ContentRect, ComposedSegmentId>\n  onDispose(): void\n  isFocused(): boolean\n  readonly inspector?: CanvasInspector\n}\n\nlet zIndexTieBreaker = 0\n\nexport class CanvasTextDecoration implements CanvasDrawable, Disposable {\n  readonly #logger = logger.createLogger('CanvasTextDecoration')\n  readonly #disposables = new DisposableStack()\n  readonly #interactiveGeometryManager: InteractiveGeometryManager<ContentRect, ComposedSegmentId>\n  readonly #rangesGroup: LiveTextRangeGroupWithGeometry<unknown, unknown>\n  readonly #isFocused: () => boolean\n  #segments: readonly SegmentInternal[]\n  #boundingRect: ContentRect | null = null\n  #rects: ContentRect[] | null = null\n  #visibleRects: ContentRect[] | null = null\n  // This is used to ensure that decorations with the same text-order have different z-indexes\n  // This is needed to make rendering/intersection testing deterministic.\n  // We want to have a number that is between 0 and 1 to not affect the z-index provided by text-order.\n  readonly #zIndexTieBreaker = zIndexTieBreaker++ / 1e9\n  #zIndex = 0\n\n  readonly id: TextDecorationId\n  readonly #inspector?: CanvasInspector\n\n  constructor(options: CanvasDecorationCreateOptions) {\n    this.id = options.decorationId\n    this.#inspector = options.inspector\n    this.#interactiveGeometryManager = options.interactiveGeometryManager\n    this.#rangesGroup = options.rangesGroup\n    this.#segments = options.segments.map(segment => ({\n      ...segment,\n      rects: [],\n      rawRects: [],\n    }))\n    this.#isFocused = options.isFocused\n\n    this.#disposables.defer(() => {\n      options.onDispose()\n      this.removeInteractiveGeometry()\n      this.#inspector?.({\n        kind: 'removeElement',\n        id: this.id,\n      })\n    })\n\n    this.#createInspectorDOM()\n  }\n\n  get segments(): readonly SegmentAndRects[] {\n    return this.#segments\n  }\n\n  get zIndex(): number {\n    // Focused decoration should be on top, otherwise we use the text position of the leftmost segment to determine z-index\n    return this.#isFocused() ? Number.MAX_SAFE_INTEGER : this.#zIndex + this.#zIndexTieBreaker\n  }\n\n  get opaqueRects(): readonly ContentRect[] {\n    // All of the decoration rects are opaque when focused, so decorations in the back\n    // will not show through.\n    return this.#isFocused() ? this.rects : []\n  }\n\n  get boundingRect(): ContentRect {\n    if (this.#boundingRect) return this.#boundingRect\n    else {\n      this.#boundingRect = pipe(\n        this.#segments.flatMap(s => s.rects),\n        Rect.unionOrElse(Rect.collapsed<'Content'>()),\n      )\n      return this.#boundingRect\n    }\n  }\n\n  get visibleRects(): readonly ContentRect[] {\n    if (this.#visibleRects) return this.#visibleRects\n    else {\n      this.#visibleRects = pipe(\n        this.#segments,\n        // NOTE: we are assuming the background/underline colors are not transparent\n        filter(s => !!s.background || !!s.underline),\n        // compute line bounding boxes for each segment individually\n        flatMap(s => getLineBoundingBoxes(s.rects)),\n        toArray,\n      )\n      return this.#visibleRects\n    }\n  }\n\n  get rects(): readonly ContentRect[] {\n    if (this.#rects) return this.#rects\n    else {\n      this.#rects = pipe(\n        this.#segments.flatMap(s => s.rects),\n        // compute line bounding boxes across all rects\n        getLineBoundingBoxes,\n      )\n      return this.#rects\n    }\n  }\n\n  toString(): string {\n    return `CanvasTextDecoration({ id: ${this.id}, rangesGroup: ${this.#rangesGroup} })`\n  }\n\n  /**\n   * Remove all interactive geometry\n   */\n  removeInteractiveGeometry() {\n    for (const segment of this.#segments) {\n      void this.#interactiveGeometryManager.remove(createComposedSegmentId(this.id, segment.id))\n      this.#setInteractiveInInspectorDOM(segment.id, false)\n    }\n  }\n\n  /**\n   * Register all interactive ranges for intersection testing\n   */\n  registerInteractiveGeometry() {\n    for (const segment of this.#segments) {\n      if (segment.interactive) {\n        void this.#interactiveGeometryManager.upsert(\n          createComposedSegmentId(this.id, segment.id),\n          segment.rects,\n        )\n        this.#setInteractiveInInspectorDOM(segment.id, true)\n      } else {\n        void this.#interactiveGeometryManager.remove(createComposedSegmentId(this.id, segment.id))\n        this.#setInteractiveInInspectorDOM(segment.id, false)\n      }\n    }\n  }\n\n  patchSegment(\n    segmentId: TextDecorationSegmentId,\n    { interactive, underline, background }: Partial<SegmentPatchOptions>,\n  ): void {\n    let interactiveSegmentsChanged = false\n    this.#segments = this.#segments.map(segment => {\n      if (segment.id !== segmentId) return segment\n\n      if (interactive !== segment.interactive) {\n        interactiveSegmentsChanged = true\n      }\n\n      const updatedUnderline = underline === null ? undefined : underline ?? segment.underline\n      const updatedBackground = background === null ? undefined : background ?? segment.background\n\n      return {\n        id: segment.id,\n        rawRects: segment.rawRects,\n        rects: segment.rawRects.map(adjustRectToIncludeUnderlineAndEllipsis(updatedUnderline)),\n        backgroundAnimation: extractBackgroundAnimation(background, segment),\n        underlineAnimation: extractUnderlineAnimation(underline, segment),\n        interactive: interactive ?? segment.interactive,\n        underline: updatedUnderline,\n        background: updatedBackground,\n      }\n    })\n\n    if (interactiveSegmentsChanged) {\n      this.registerInteractiveGeometry()\n    }\n    // Invalidate visibleRects\n    this.#visibleRects = null\n  }\n\n  async layout(minimumRevision: TextAndGeometryRevision): Promise<ContentRect> {\n    // Make sure to return old boundingRect if we are disposed.\n    // This can be called asynchronously from the CanvasRenderer.\n    if (this.#disposed) return this.boundingRect\n\n    const rects = await pipe(\n      this.#rangesGroup.getRects(minimumRevision),\n      AsyncResult.match({\n        success: ({ rects }) => rects,\n        failure: error => {\n          this.#logger.error('Unexpected error getting rects - returning empty rects', error)\n          return []\n        },\n      }),\n    )\n\n    // Make sure we return if we are disposed after awaiting for rects\n    if (this.#disposed) return this.boundingRect\n\n    this.#segments = pipe(zip(this.#segments, rects), toArray, segments =>\n      segments.map(([s, rects]) => ({\n        ...s,\n        rawRects: pipe(\n          rects,\n          getLineBoundingBoxes,\n          // Numbers must be integer to avoid antialiasing.\n          rects => rects.map(ContentRect.map(round)),\n        ),\n        rects: pipe(\n          rects.map(adjustRectToIncludeUnderlineAndEllipsis(s.underline)),\n          getLineBoundingBoxes,\n          // Numbers must be integer to avoid antialiasing.\n          rects => rects.map(ContentRect.map(round)),\n        ),\n      })),\n    )\n\n    this.registerInteractiveGeometry()\n\n    // Update z-index value\n    this.#zIndex = pipe(\n      zip(this.#segments, this.#rangesGroup.ranges),\n      // Order by interactive ranges since this is what the user sees and interacts with\n      filter(([segment]) => !!segment.interactive),\n      map(([_, range]) => range.start),\n      toArray,\n      // fallback to all ranges\n      ranges => (ranges.length === 0 ? this.#rangesGroup.ranges.map(r => r.start) : ranges),\n      // Return the min start position as the z-index\n      ranges => (ranges.length === 0 ? 0 : Math.min(...ranges)),\n    )\n\n    // reset rects to force recalculation.\n    this.#boundingRect = null\n    this.#rects = null\n    this.#visibleRects = null\n\n    this.#updateInspectorDOM()\n\n    return this.boundingRect\n  }\n\n  *render(ctx: OffscreenCanvasRenderingContext2D) {\n    if (this.#disposed) return\n\n    while (true) {\n      ctx.save()\n      const hasAnimatingBackground = this.#renderBackground(ctx)\n      const hasAnimatingUnderline = this.#renderUnderline(ctx)\n      ctx.restore()\n\n      // yield to continue animating if needed\n      if (hasAnimatingBackground || hasAnimatingUnderline) yield\n      else return\n    }\n  }\n\n  get #disposed() {\n    return this.#disposables.disposed\n  }\n\n  #renderBackground(ctx: OffscreenCanvasRenderingContext2D) {\n    let hasAnimatingSegments = false\n\n    for (const segment of this.#segments) {\n      const animation = segment.backgroundAnimation\n      const background =\n        segment.background ?? (animation?.running ? animation?.metadata.background : undefined)\n      if (!background) continue\n\n      ctx.save()\n      if (animation) {\n        const { alpha, running } = stepAnimation(animation)\n        hasAnimatingSegments ||= running\n        ctx.globalAlpha = alpha\n      }\n      for (const rect of segment.rawRects) {\n        if (rect.width <= 0 || rect.height <= 0) continue\n\n        ctx.fillStyle = background.color\n        ctx.fillRect(rect.x, rect.y, rect.width, rect.height)\n      }\n      ctx.restore()\n    }\n    return hasAnimatingSegments\n  }\n\n  #renderUnderline(ctx: OffscreenCanvasRenderingContext2D) {\n    let hasAnimatingSegments = false\n\n    for (const segment of this.#segments) {\n      const animation = segment.underlineAnimation\n      const underline =\n        segment.underline ?? (animation?.running ? animation?.metadata.underline : undefined)\n      if (!underline) continue\n\n      const { underlineThickness, verticalOffset } = underlineThicknessAndOffsetInLogicalPixels(\n        segment.underline,\n      )\n\n      ctx.save()\n      if (animation) {\n        const { alpha, running } = stepAnimation(animation)\n        hasAnimatingSegments ||= running\n        ctx.globalAlpha = alpha\n      }\n      for (const rect of segment.rawRects) {\n        if (rect.width <= 0 || rect.height <= 0) continue\n\n        ctx.lineWidth = underlineThickness\n        ctx.strokeStyle = underline.color\n        ctx.setLineDash(\n          underline.style === 'dotted' ? [underlineThickness, underlineThickness] : [],\n        )\n        ctx.lineCap = 'butt'\n        ctx.beginPath()\n        ctx.moveTo(rect.x, rect.y + rect.height + verticalOffset)\n        ctx.lineTo(rect.x + rect.width, rect.y + rect.height + verticalOffset)\n        ctx.stroke()\n      }\n      ctx.restore()\n\n      // Draw ellispsis\n      const lastRect = segment.rawRects.at(-1)\n      if (underline.style === 'ellipsis' && lastRect) {\n        if (lastRect.width <= 0 || lastRect.height <= 0) continue\n\n        ctx.beginPath()\n        ctx.lineWidth = 0\n        ctx.fillStyle = underline.color\n        const x = lastRect.x + lastRect.width\n        const y = lastRect.y + lastRect.height + verticalOffset\n        const { radius, gap } = getEllipsisRadiusAndGap(underlineThickness)\n        const oneTurn = 2 * Math.PI\n        ctx.arc(x + gap * 1, y, radius, 0, oneTurn)\n        ctx.arc(x + gap * 2, y, radius, 0, oneTurn)\n        ctx.arc(x + gap * 3, y, radius, 0, oneTurn)\n        ctx.fill()\n      }\n    }\n\n    return hasAnimatingSegments\n  }\n\n  #createInspectorDOM() {\n    const inspector = this.#inspector\n    if (!inspector) return\n\n    inspector({\n      kind: 'createElement',\n      tagName: 'text-decoration',\n      id: this.id,\n      parentId: null,\n    })\n\n    // NOTE: If number of segments changes, we need to create/remove segments\n    //       from the inspector as well.\n    this.#segments.forEach(segment => {\n      inspector({\n        kind: 'createElement',\n        tagName: 'text-decoration-segment',\n        id: segment.id,\n        parentId: this.id,\n      })\n      inspector({\n        kind: 'updateAttributes',\n        id: segment.id,\n        attributes: {\n          segmentId: segment.id,\n          interactive: segment.interactive ? 'true' : 'false',\n        },\n      })\n    })\n  }\n\n  #updateInspectorDOM() {\n    const inspector = this.#inspector\n    if (!inspector) return\n    const decorationRect = this.boundingRect\n\n    inspector({\n      kind: 'updateAttributes',\n      id: this.id,\n      attributes: {\n        decorationId: this.id,\n        zIndex: `${this.zIndex}`,\n        focused: this.#isFocused() ? 'true' : null,\n\n        style: Rect.isCollapsed(decorationRect)\n          ? null\n          : `position: absolute; z-index: ${Math.floor(this.zIndex)}; left: ${decorationRect.x}px; top: ${decorationRect.y}px; width: ${decorationRect.width}px; height: ${decorationRect.height}px;`,\n      },\n    })\n\n    this.#segments.forEach(segment => {\n      const segmentRect = pipe(segment.rects, Rect.unionOrElse(null))\n      inspector({\n        kind: 'updateAttributes',\n        id: segment.id,\n        attributes: {\n          segmentId: segment.id,\n          ...(segment.underline\n            ? transformObject(segment.underline, key => `underline-${key}`, String)\n            : ({\n                align: null,\n                color: null,\n                style: null,\n                thickness: null,\n              } satisfies Record<keyof UnderlineRenderOptions, null>)),\n          ...(segment.background\n            ? transformObject(segment.background, key => `background-${key}`, String)\n            : ({\n                color: null,\n              } satisfies Record<keyof BackgroundRenderOptions, null>)),\n          style: segmentRect\n            ? `position: absolute; left: ${segmentRect.x - decorationRect.x}px; top: ${segmentRect.y - decorationRect.y}px; width: ${segmentRect.width}px; height: ${segmentRect.height}px;`\n            : null,\n          interactive: segment.interactive ? 'true' : null,\n        },\n      })\n\n      inspector({\n        kind: 'removeAllChildren',\n        id: segment.id,\n      })\n      if (segmentRect) {\n        segment.rects.forEach((rect, index) => {\n          inspector({\n            kind: 'createElement',\n            tagName: 'text-decoration-rect',\n            id: `${segment.id}-${index}`,\n            parentId: segment.id,\n          })\n\n          inspector({\n            kind: 'updateAttributes',\n            id: `${segment.id}-${index}`,\n            attributes: {\n              ...transformObject(rect, key => `rect-${key}`, String),\n              style: `left: ${rect.x - segmentRect.x}px; top: ${rect.y - segmentRect.y}px; width: ${rect.width}px; height: ${rect.height}px; position: absolute;`,\n              class: 'reset-absolute-origin',\n            },\n          })\n        })\n      }\n    })\n  }\n\n  #setInteractiveInInspectorDOM(segmentId: TextDecorationSegmentId, interactive: boolean) {\n    if (!this.#inspector || this.#disposed) return\n    this.#inspector({\n      kind: 'updateAttributes',\n      id: segmentId,\n      attributes: {\n        interactive: interactive ? 'true' : 'false',\n      },\n    })\n  }\n\n  [Symbol.dispose]() {\n    this.#disposables.dispose()\n  }\n}\n\nfunction getEllipsisRadiusAndGap(underlineThickness: number) {\n  return {\n    radius: 0.6 * underlineThickness,\n    gap: 2.5 * underlineThickness,\n  }\n}\n\nfunction extractBackgroundAnimation(\n  backgroundPatch: BackgroundRenderOptions | null | undefined,\n  segment: Pick<SegmentInternal, 'background' | 'backgroundAnimation'>,\n): SegmentInternal['backgroundAnimation'] {\n  if (backgroundPatch && !segment.background) {\n    return {\n      kind: 'fadeIn',\n      startTime: performance.now(),\n      duration: 200,\n      metadata: { background: backgroundPatch },\n      running: true,\n    }\n  } else if (backgroundPatch === null && segment.background) {\n    return {\n      kind: 'fadeOut',\n      startTime: performance.now(),\n      duration: 150,\n      metadata: { background: segment.background },\n      running: true,\n    }\n  }\n  return segment?.backgroundAnimation\n}\n\nfunction extractUnderlineAnimation(\n  underlinePatch: UnderlineRenderOptions | null | undefined,\n  segment: Pick<SegmentInternal, 'underline' | 'underlineAnimation'>,\n): SegmentInternal['underlineAnimation'] {\n  if (underlinePatch && !segment.underline) {\n    return {\n      kind: 'fadeIn',\n      startTime: performance.now(),\n      duration: 200,\n      metadata: { underline: underlinePatch },\n      running: true,\n    }\n  } else if (underlinePatch === null && segment.underline) {\n    return {\n      kind: 'fadeOut',\n      startTime: performance.now(),\n      duration: 150,\n      metadata: { underline: segment.underline },\n      running: true,\n    }\n  }\n  return segment?.underlineAnimation\n}\n\nfunction underlineThicknessAndOffsetInLogicalPixels(\n  underlineRenderOptions: UnderlineRenderOptions | undefined,\n) {\n  const underlineThickness = underlineRenderOptions?.thickness ?? DEFAULT_UNDERLINE_THICKNESS\n  const align = underlineRenderOptions?.align ?? DEFAULT_UNDERLINE_ALIGNMENT\n  const verticalOffset =\n    align === 'inside' ? -underlineThickness / 2 : align === 'center' ? 0 : underlineThickness / 2\n\n  return { underlineThickness, verticalOffset, align }\n}\n\nfunction adjustRectToIncludeUnderlineAndEllipsis(\n  underlineOptions?: UnderlineRenderOptions,\n): (rect: ContentRect) => ContentRect {\n  return rect => {\n    const { underlineThickness, align } =\n      underlineThicknessAndOffsetInLogicalPixels(underlineOptions)\n\n    const extraHeight =\n      align === 'center' ? underlineThickness / 2 : align === 'outside' ? underlineThickness : 0\n\n    const ellipsis = getEllipsisRadiusAndGap(\n      underlineOptions?.thickness ?? DEFAULT_UNDERLINE_THICKNESS,\n    )\n    const extraWidth =\n      underlineOptions?.style === 'ellipsis' ? 3 * ellipsis.gap + ellipsis.radius : 0\n\n    return {\n      ...rect,\n      // Round up to the nearest pixel\n      height: round(rect.height + extraHeight + 0.5),\n      // Round up to the nearest pixel\n      width: round(rect.width + extraWidth + 0.5),\n    }\n  }\n}\n","import type { DocumentID } from '@grammarly/feature-connector'\nimport type {\n  GetBoundingRectsResponse,\n  GetRectsResponse,\n  TextDocumentGeometryInfo,\n} from '@grammarly/feature-document-session'\nimport { NonEmptyArray } from '@grammarly/util-array'\nimport type { DeltaJson } from '@grammarly/util-delta'\nimport { dispose } from '@grammarly/util-disposable'\nimport { UnreachableCaseError } from '@grammarly/util-error'\nimport { isNonNullable, pipe } from '@grammarly/util-function'\nimport {\n  ContentPoint,\n  ContentRect,\n  GeometryRevision,\n  InteractiveGeometryManager,\n  ViewportPoint,\n  ViewportRect,\n  type PointerEvent,\n  type PointerEventKind,\n  type PointerEvents,\n  type PointLike,\n  type RectLike,\n  type TextAndGeometryRevision,\n} from '@grammarly/util-geometry'\nimport { filter, map, toArray, toSet } from '@grammarly/util-iterable'\nimport { logger, type Logger } from '@grammarly/util-logging'\nimport { Emitter, State } from '@grammarly/util-reactive'\nimport { AsyncResult, Result } from '@grammarly/util-result'\nimport { createSingletonTaskQueue, microtaskScheduler } from '@grammarly/util-scheduling'\nimport { equal as setEqual } from '@grammarly/util-set'\nimport {\n  TextRange,\n  TextRevision,\n  TextRevisionSynchronizedQueue,\n  type TextChange,\n  type TextRangeId,\n  type TextRangeUpdateSemantics,\n} from '@grammarly/util-text'\nimport {\n  TextRangeGeometryManager,\n  type TextRangeGeometryFetchMetrics,\n  type TextRangeGroupId,\n} from '@grammarly/util-text-range-geometry'\nimport { tracer } from '@grammarly/util-tracing'\nimport {\n  createPrefixedCanvasInspector,\n  createScopedCanvasInspector,\n  type CanvasInspector,\n} from './CanvasInspector'\nimport { DefaultCanvasRenderer, type CanvasRenderer } from './CanvasRenderer'\nimport {\n  CanvasTextDecoration,\n  extractDecorationAndSegmentId,\n  type ComposedSegmentId,\n  type SegmentPatchOptions,\n} from './CanvasTextDecoration'\nimport type {\n  BackgroundRenderOptions,\n  TextDecorationId,\n  TextDecorationSegmentId,\n  UnderlineRenderOptions,\n} from './TextDecoration'\nimport type { TextDecorationsHideReason } from './TextDecorationStore'\n\n/**\n * Options to initialize an instance of `CanvasTextDecorationsManager`\n * @internal\n */\nexport interface CanvasTextDecorationsManagerInitOptions {\n  readonly documentId: DocumentID\n  /** OffscreenCanvas instance to render decorations */\n  readonly canvas: OffscreenCanvas\n  /** Device pixel ratio for the screen where the decorations canvas is mounted */\n  readonly devicePixelRatio: number\n  /** Document geometry */\n  readonly documentGeometry: TextDocumentGeometryInfo | null\n  /**\n   * Oversampling factor to use when rendering decorations to canvas.\n   * The higher the value, the higher the quality, but the more\n   * CPU and memory resources will be consumed.\n   */\n  readonly overSamplingFactor: OverSamplingFactor\n  /**\n   * The initial text and geometry revision\n   */\n  readonly initialRevision: TextAndGeometryRevision\n  /**\n   * List of reasons for hiding all decorations\n   */\n  readonly initialHideAllReasons: readonly TextDecorationsHideReason[]\n  /**\n   * Callback to notify of pointer events coming from decoration interactions\n   */\n  emitSegmentPointerEvents(events: SegmentPointerEvents): void\n  /**\n   * Emit decoration metrics\n   */\n  emitDecorationMetrics(metrics: TextDecorationMetrics): void\n  /**\n   * Emit the set of visible on-screen decorations any time it changes\n   */\n  emitVisibleOnscreenDecorationsChange(\n    visibleOnscreenDecorations: ReadonlySet<TextDecorationId>,\n  ): void\n  /**\n   * Emit the set of reasons for which all decorations are hidden\n   */\n  emitHideAllReasons(hideAllReasons: ReadonlySet<TextDecorationsHideReason>): void\n  /**\n   * Callback to get the rectangles in document viewport coordinates for the given text ranges\n   */\n  getRects(ranges: ReadonlyMap<TextRangeId, TextRange>): AsyncResult<GetRectsResponse<TextRangeId>>\n  /**\n   * Callback to get the bounding boxes in document viewport coordinates for the given text ranges\n   */\n  getBoundingRects(\n    ranges: ReadonlyMap<TextRangeId, TextRange>,\n  ): AsyncResult<GetBoundingRectsResponse<TextRangeId>>\n\n  readonly inspector?: CanvasInspector\n}\n\n/**\n * Options for creating a new text decoration\n * @internal\n */\nexport interface TextDecorationCreateOptions {\n  /** Unique text decoration identifier */\n  readonly id: TextDecorationId\n  /** Decoration segments */\n  readonly segments: readonly SegmentCreateOptions[]\n  /** Text revision for which this decoration was created */\n  readonly revision: TextRevision\n  /** Text decoration visibility */\n  readonly visibility: 'visible' | 'hidden'\n}\n\n/**\n * Options for creating a new decoration segment\n * @internal\n */\nexport interface SegmentCreateOptions {\n  readonly id: TextDecorationSegmentId\n  /** Text range this segment covers */\n  readonly range: TextRange\n  /** The text range update semantics (resize or collapse) */\n  readonly updateSemantics: TextRangeUpdateSemantics\n  /** Whether this text range reports hover and click events */\n  readonly interactive?: boolean\n  /** Visual metadata for the underline, or `undefined` for no underline */\n  readonly underline?: UnderlineRenderOptions\n  /** Visual metadata for the background, or `undefined` for no background */\n  readonly background?: BackgroundRenderOptions\n}\n\n/**\n * Pointer event with a viewport position\n * @internal\n */\nexport interface PointerEventPosition {\n  readonly kind: 'pointerMove' | 'pointerUp' | 'pointerDown'\n  readonly position: ViewportPoint\n}\n\n/**\n * Pointer event emitted when interacting with a segment\n * @internal\n */\nexport interface SegmentPointerEvent<Kind = PointerEventKind> {\n  readonly kind: Kind\n  readonly id: TextDecorationId\n  readonly segmentId: TextDecorationSegmentId\n  readonly position: ViewportPoint\n  readonly rect: ViewportRect\n  readonly decorationRects: readonly ViewportRect[]\n}\n\n/**\n * Pointer events emitted when interactive with segments\n * @internal\n */\nexport interface SegmentPointerEvents {\n  readonly pointerEnter?: SegmentPointerEvent<'pointerEnter'>\n  readonly pointerLeave?: SegmentPointerEvent<'pointerLeave'>\n  readonly pointerDown?: SegmentPointerEvent<'pointerDown'>\n  readonly pointerUp?: SegmentPointerEvent<'pointerUp'>\n  readonly pointerClick?: SegmentPointerEvent<'pointerClick'>\n}\n\n/**\n * Metrics about text decorations\n * @internal\n */\nexport interface TextDecorationMetrics extends TextRangeGeometryFetchMetrics {\n  /** Number of decorations that got rendered during the last render loop */\n  readonly decorationsRenderedOnLastRenderLoop: number\n  /** Number of interactive rectangles registered */\n  readonly interactiveRectCount: number\n  /** Number of rendered visible onscreen decorations */\n  readonly renderedVisibleOnscreenDecorationCount: number\n  /** Total number of visible decorations (rendered and not rendered) */\n  readonly visibleDecorationCount: number\n  /** Total number of decorations (hidden and visible, rendered and not rendered) */\n  readonly allDecorationCount: number\n}\n\n/**\n * Supported oversampling factors\n * @internal\n */\nexport type OverSamplingFactor = 1 | 2 | 4\n\n/** @internal */\ninterface TextDecorationAddRequest {\n  readonly kind: 'add'\n  readonly options: TextDecorationCreateOptions\n}\n\n/** @internal */\ninterface TextDecorationRemoveRequest {\n  readonly kind: 'remove'\n  readonly ids: ReadonlySet<TextDecorationId>\n}\n\n/** @internal */\ntype TextDecorationAddOrRemoveRequest = TextDecorationAddRequest | TextDecorationRemoveRequest\n\n/**\n * Canvas Text decorations manager API\n * @internal\n */\nexport interface CanvasTextDecorationManager {\n  /** Notify the worker that a pointer event occurred. */\n  notifyPointerEvent(event: PointerEventPosition): void\n  /** Notify the worker that the document geometry has changed. */\n  notifyDocumentGeometryChanged(\n    documentGeometry: TextDocumentGeometryInfo,\n    devicePixelRatio: number,\n  ): AsyncResult<void>\n  /** Notify the worker that the text has changed. */\n  notifyTextChanged(change: TextChange<DeltaJson>): void\n\n  /** Add a new decoration */\n  upsert(options: TextDecorationCreateOptions): AsyncResult<void>\n  /** Remove multiple decorations */\n  remove(ids: readonly TextDecorationId[]): void\n  /** Set the visibility for multiple decorations */\n  setVisibility(ids: readonly TextDecorationId[], visible: boolean): void\n  /**\n   * Hide all decorations. This operation does not affect the visibility state\n   * of decorations. 'visible' or 'focused' decorations will keep their\n   * state. Decorations will be shown again after all hiding reasons have been\n   * remvoed by calling `removeHideAllReason(reasons)`.\n   * they will be shown again.\n   * @param reasons - A non-emtpy list of reasons for hiding the decorations.\n   */\n  addHideAllReasons(reasons: NonEmptyArray<TextDecorationsHideReason>): void\n  /**\n   * Remove a reason that triggered hiding of all text decorations.\n   * Once all reasons have been removed, decorations will be shown again.\n   * This operation does not affect the visibility state of decorations.\n   * Only 'visible' or 'focused' decorations will be shown once all reasons are removed.\n   * @param reasons - The reasons to remove\n   */\n  removeHideAllReasons(reasons: readonly TextDecorationsHideReason[]): void\n  /** Patch a decoration's segment */\n  patchSegment(\n    id: TextDecorationId,\n    segmentId: TextDecorationSegmentId,\n    patch: Partial<SegmentPatchOptions>,\n  ): void\n  /**\n   * Sets or unsets the focused decoration.\n   */\n  focus(decorationId: TextDecorationId | null): void\n}\n\n/**\n * Canvas Text decorations manager default implementation.\n * This class is instantiated in a worker and manages and renders decorations to an\n * offscreen canvas instance.\n * @internal\n */\nexport class DefaultCanvasTextDecorationManager implements CanvasTextDecorationManager {\n  static #idSeq = 0\n  readonly #disposables = new DisposableStack()\n  readonly #logger: Logger\n  readonly #ctx: OffscreenCanvasRenderingContext2D\n  #documentGeometry: TextDocumentGeometryInfo | null\n  readonly #getRects: (\n    ranges: ReadonlyMap<TextRangeId, TextRange>,\n  ) => AsyncResult<GetRectsResponse<TextRangeId>>\n  readonly #getBoundingRects: (\n    ranges: ReadonlyMap<TextRangeId, TextRange>,\n  ) => AsyncResult<GetBoundingRectsResponse<TextRangeId>>\n  readonly #emitSegmentPointerEvents: (events: SegmentPointerEvents) => void\n  readonly #emitHideAllReasons: (hideAllReasons: ReadonlySet<TextDecorationsHideReason>) => void\n  readonly #textRangeGeometryManager: TextRangeGeometryManager<undefined, TextDecorationId>\n  readonly #interactiveGeometryManager: InteractiveGeometryManager<ContentRect, ComposedSegmentId>\n  readonly #decorations = new Map<TextDecorationId, CanvasTextDecoration>()\n  readonly #pointerMove = new Emitter<ContentPoint>()\n  readonly #pointerUp = new Emitter<ContentPoint>()\n  readonly #pointerDown = new Emitter<ContentPoint>()\n  readonly #pendingDecorations = new Map<TextDecorationId, AbortController>()\n  #visibleOnscreenDecorations: ReadonlySet<TextDecorationId> = new Set()\n  readonly #visibleDecorations = new Set<TextDecorationId>()\n  #focusedDecorationId: TextDecorationId | null = null\n  readonly #decorationMetrics = new State<TextDecorationMetrics>({\n    decorationsRenderedOnLastRenderLoop: 0,\n    interactiveRectCount: 0,\n    renderedVisibleOnscreenDecorationCount: 0,\n    visibleDecorationCount: 0,\n    allDecorationCount: 0,\n    rectCount: 0,\n    rangeCount: 0,\n  })\n  readonly #hideAllReasons = new Set<TextDecorationsHideReason>()\n  readonly #canvasRenderer: CanvasRenderer<CanvasTextDecoration>\n\n  readonly #documentGeometryUpdateQueue = this.#disposables.use(\n    createSingletonTaskQueue(\n      (documentGeometry: TextDocumentGeometryInfo, devicePixelRatio: number) =>\n        this.#handleGeometryChange(documentGeometry, devicePixelRatio),\n      microtaskScheduler,\n    ),\n  )\n\n  /**\n   * Queue of pending add/remove requests.\n   * The add requests (and subsequent removals) are queued when the text-revision referred to in `add` is unknown.\n   * When text-changes are received, all additions for which the revision is known (and subsequent removals)\n   * will be processed.\n   */\n  readonly #textRevisionSyncQueue =\n    new TextRevisionSynchronizedQueue<TextDecorationAddOrRemoveRequest>()\n\n  readonly #id = `canvas-text-decoration-manager-${DefaultCanvasTextDecorationManager.#idSeq++}`\n  readonly #inspector: CanvasInspector | undefined\n\n  constructor(options: CanvasTextDecorationsManagerInitOptions) {\n    this.#logger = logger.createLogger('CanvasTextDecorationManager', options.documentId)\n    this.#ctx = options.canvas.getContext('2d')!\n    this.#emitSegmentPointerEvents = options.emitSegmentPointerEvents\n    this.#emitHideAllReasons = options.emitHideAllReasons\n    this.#getRects = options.getRects\n    this.#getBoundingRects = options.getBoundingRects\n    this.#documentGeometry = options.documentGeometry\n\n    this.#inspector = options.inspector\n    this.#inspector?.({\n      kind: 'createElement',\n      id: this.#id,\n      tagName: 'canvas-text-decoration-manager',\n      parentId: null,\n    })\n\n    this.#canvasRenderer = this.#disposables.use(\n      new DefaultCanvasRenderer<CanvasTextDecoration>({\n        canvas: options.canvas,\n        context: this.#ctx,\n        devicePixelRatio: options.devicePixelRatio,\n        oversamplingFactor: options.overSamplingFactor,\n        viewportGeometry: ContentRect.create({\n          x: this.#documentGeometry?.scrollPosition?.x ?? 0,\n          y: this.#documentGeometry?.scrollPosition?.y ?? 0,\n          width: this.#documentGeometry?.documentFrame.width ?? 0,\n          height: this.#documentGeometry?.documentFrame.height ?? 0,\n        }),\n        emitRenderMetrics: metrics => {\n          const renderedVisibleOnscreenDecorations = pipe(\n            metrics.renderedVisibleOnscreenDrawables,\n            map(drawable => drawable.id),\n            toSet,\n          )\n          const visibleDecorations = pipe(\n            metrics.visibleDrawables,\n            map(drawable => drawable.id),\n            toSet,\n          )\n          const allDecorations = pipe(\n            metrics.allDrawables,\n            map(drawable => drawable.id),\n            toSet,\n          )\n          if (!setEqual(renderedVisibleOnscreenDecorations, this.#visibleOnscreenDecorations)) {\n            this.#visibleOnscreenDecorations = renderedVisibleOnscreenDecorations\n            options.emitVisibleOnscreenDecorationsChange(renderedVisibleOnscreenDecorations)\n          }\n          this.#updateMetrics({\n            decorationsRenderedOnLastRenderLoop: metrics.drawablesRenderedOnLastRenderLoop,\n            renderedVisibleOnscreenDecorationCount: renderedVisibleOnscreenDecorations.size,\n            visibleDecorationCount: visibleDecorations.size,\n            allDecorationCount: allDecorations.size,\n          })\n        },\n      }),\n    )\n\n    this.#textRangeGeometryManager = new TextRangeGeometryManager({\n      initialRevision: options.initialRevision,\n      initialVisibleTextRange: this.#documentGeometry?.visibleTextRange ?? { start: 0, end: 0 },\n      getRects: ranges =>\n        pipe(\n          this.#getRects(ranges),\n          AsyncResult.map(({ rects, revision }) => {\n            // Make sure the response and the documentGeometry are on the same revision before using scrollPosition\n            if (\n              revision.geometry !== this.#documentGeometry?.revision &&\n              this.#documentGeometry?.scrollPosition !== undefined\n            ) {\n              this.#logger.warn(\n                `Expected document geometry revision ${this.#documentGeometry.revision} to equal revision ${revision.geometry} from getRects() response`,\n              )\n            }\n            return {\n              rects: new Map(\n                pipe(\n                  rects.entries(),\n                  map(([id, rects]) => [\n                    id,\n                    rects.map(rect =>\n                      ContentRect.create({\n                        ...rect,\n                        x: rect.x + (this.#documentGeometry?.scrollPosition?.x ?? 0),\n                        y: rect.y + (this.#documentGeometry?.scrollPosition?.y ?? 0),\n                      }),\n                    ),\n                  ]),\n                ),\n              ),\n              revision,\n            }\n          }),\n        ),\n      getBoundingRects: ranges =>\n        pipe(\n          this.#getBoundingRects(ranges),\n          AsyncResult.map(({ rects, revision }) => {\n            // Make sure the response and the documentGeometry are on the same revision before using scrollPosition\n            if (\n              revision.geometry !== this.#documentGeometry?.revision &&\n              this.#documentGeometry?.scrollPosition !== undefined\n            ) {\n              this.#logger.warn(\n                `Expected document geometry revision ${this.#documentGeometry.revision} to equal revision ${revision.geometry} from getRects() response`,\n              )\n            }\n            return {\n              rects: new Map(\n                pipe(\n                  rects.entries(),\n                  map(([id, rect]) => [\n                    id,\n                    ContentRect.create({\n                      ...rect,\n                      x: rect.x + (this.#documentGeometry?.scrollPosition?.x ?? 0),\n                      y: rect.y + (this.#documentGeometry?.scrollPosition?.y ?? 0),\n                    }),\n                  ]),\n                ),\n              ),\n              revision,\n            }\n          }),\n        ),\n      emitMetrics: metrics => this.#updateMetrics(metrics),\n    })\n\n    this.#disposables.use(\n      this.#decorationMetrics.subscribe(metrics => options.emitDecorationMetrics(metrics)),\n    )\n\n    this.#interactiveGeometryManager = this.#disposables.use(\n      new InteractiveGeometryManager<ContentRect, ComposedSegmentId>({\n        label: options.documentId,\n        pointerMove: this.#pointerMove,\n        pointerDown: this.#pointerDown,\n        pointerUp: this.#pointerUp,\n        getViewport: () =>\n          ContentRect.create({\n            x: this.#documentGeometry?.scrollPosition?.x ?? 0,\n            y: this.#documentGeometry?.scrollPosition?.y ?? 0,\n            width: this.#documentGeometry?.documentFrame.width ?? 0,\n            height: this.#documentGeometry?.documentFrame.height ?? 0,\n          }),\n        compareZIndex: (rectAndGeoA, rectAndGeoB) => {\n          const a = extractDecorationAndSegmentId(rectAndGeoA.geometry)\n          const b = extractDecorationAndSegmentId(rectAndGeoB.geometry)\n\n          const decorationA = this.#decorations.get(a.decorationId)\n          const decorationB = this.#decorations.get(b.decorationId)\n          if (!decorationA || !decorationB) return 0\n\n          // If z-indices are equal, we prioritize segments with underline because they are always\n          // rendered on top of background segments\n          if (decorationA.zIndex === decorationB.zIndex) {\n            const segmentA = decorationA.segments.find(s => s.id === a.segmentId)\n            const segmentB = decorationB.segments.find(s => s.id === b.segmentId)\n            if (!segmentA || !segmentB) return 0\n\n            const scoreA = segmentA.underline ? 1 : 0\n            const scoreB = segmentB.underline ? 1 : 0\n\n            return scoreA - scoreB\n          }\n          return decorationA.zIndex - decorationB.zIndex\n        },\n        emitMetrics: metrics =>\n          this.#updateMetrics({\n            interactiveRectCount: metrics.interactiveRectCount,\n          }),\n      }),\n    )\n\n    this.#disposables.use(\n      this.#interactiveGeometryManager.onPointerEvent.subscribe(events =>\n        this.#emitPointerEvent(events),\n      ),\n    )\n\n    const hideAllReasons = NonEmptyArray.from(options.initialHideAllReasons)\n    if (hideAllReasons) {\n      this.addHideAllReasons(hideAllReasons)\n    }\n  }\n\n  notifyPointerEvent(event: PointerEventPosition): void {\n    const position = ContentPoint.create({\n      x:\n        event.position.x -\n        (this.#documentGeometry?.documentFrame.x ?? 0) +\n        (this.#documentGeometry?.scrollPosition?.x ?? 0),\n      y:\n        event.position.y -\n        (this.#documentGeometry?.documentFrame.y ?? 0) +\n        (this.#documentGeometry?.scrollPosition?.y ?? 0),\n    })\n    switch (event.kind) {\n      case 'pointerMove':\n        return this.#pointerMove.emit(position)\n      case 'pointerDown':\n        return this.#pointerDown.emit(position)\n      case 'pointerUp':\n        return this.#pointerUp.emit(position)\n      default:\n        throw new UnreachableCaseError(event.kind)\n    }\n  }\n\n  notifyDocumentGeometryChanged(\n    documentGeometry: TextDocumentGeometryInfo,\n    devicePixelRatio: number,\n  ): AsyncResult<void> {\n    return this.#documentGeometryUpdateQueue.enqueue(documentGeometry, devicePixelRatio)\n  }\n\n  notifyTextChanged(change: TextChange<DeltaJson>): void {\n    using _ = tracer.startSpan('CanvasTextDecorationManager.#handleTextChanged()', {\n      attributes: { change },\n    })\n\n    const { visibleChanged } = this.#textRangeGeometryManager.pushTextChange(change)\n\n    // Once the TextRangeGeometryManager is updated with the latest text change,\n    // push the revision to the add/remove queue to process pending additions/removals.\n    this.#textRevisionSyncQueue.pushNewTextRevision(change.revision)\n\n    const visibleChangedDecorations = pipe(\n      visibleChanged,\n      map(group => this.#decorations.get(group.metadata)),\n      filter(isNonNullable),\n      toArray,\n    )\n\n    this.#canvasRenderer.requestLayout(visibleChangedDecorations, {\n      text: this.#textRevisionSyncQueue.textRevision ?? TextRevision.initial,\n      geometry: this.#documentGeometry?.revision ?? GeometryRevision.initial,\n    })\n\n    if (visibleChangedDecorations.length > 0) {\n      this.#logger.verbose('text changed', {\n        change,\n        visibleChangedDecorationsCount: visibleChangedDecorations.length,\n        visibleChangedSegmentsCount: Array.from(visibleChangedDecorations).flatMap(d => d.segments)\n          .length,\n      })\n    }\n  }\n\n  async upsert(options: TextDecorationCreateOptions): AsyncResult<void> {\n    this.remove([options.id])\n\n    if (options.visibility === 'visible') {\n      this.#visibleDecorations.add(options.id)\n    }\n\n    const segments = NonEmptyArray.from(options.segments)\n    // TODO: Is this a valid operation?\n    if (!segments) return Result.success()\n\n    const abortController = new AbortController()\n    this.#pendingDecorations.set(options.id, abortController)\n\n    await this.#textRevisionSyncQueue.enqueue(\n      {\n        kind: 'add',\n        options,\n      },\n      options.revision,\n    )\n\n    // We want to remove the abortController corresponding to this upsert request,\n    // so that multiple upsert request for the same decoration id are handled properly.\n    if (this.#pendingDecorations.get(options.id) === abortController)\n      this.#pendingDecorations.delete(options.id)\n\n    // If the decoration got removed, just return a success\n    if (abortController.signal.aborted) return Result.success()\n\n    const rangesGroupResult = this.#textRangeGeometryManager.add({\n      id: options.id as string as TextRangeGroupId,\n      revision: options.revision,\n      geometryKind: 'rects',\n      ranges: pipe(\n        segments,\n        NonEmptyArray.map(segment => ({\n          id: segment.id as string as TextRangeId,\n          range: segment.range,\n          updateSemantics: segment.updateSemantics,\n          metadata: undefined,\n        })),\n      ),\n      metadata: options.id,\n      visible: this.#visibleDecorations.has(options.id),\n    })\n\n    if (!rangesGroupResult.ok) {\n      return rangesGroupResult\n    }\n\n    const rangesGroup = rangesGroupResult.value\n\n    const decoration = new CanvasTextDecoration({\n      decorationId: options.id,\n      rangesGroup,\n      segments,\n      interactiveGeometryManager: this.#interactiveGeometryManager,\n      isFocused: () => this.#focusedDecorationId === options.id,\n      onDispose: () => {\n        dispose(rangesGroup)\n        this.remove([options.id])\n      },\n      inspector: this.#inspector\n        ? createPrefixedCanvasInspector(\n            this.#id,\n            createScopedCanvasInspector(this.#id, this.#inspector),\n          )\n        : undefined,\n    })\n\n    this.#decorations.set(options.id, decoration)\n\n    this.#canvasRenderer.add([\n      {\n        drawable: decoration,\n        visible: this.#visibleDecorations.has(options.id),\n        onscreen: TextRange.intersect(\n          rangesGroup.boundingRange,\n          this.#documentGeometry?.visibleTextRange ?? { start: 0, end: 0 },\n        ),\n      },\n    ])\n\n    this.#logger.verbose(\n      `added ${this.#visibleDecorations.has(options.id) ? 'visible' : 'hidden'} decoration #${options.id}`,\n    )\n\n    return Result.success()\n  }\n\n  remove(ids: Iterable<TextDecorationId>): void {\n    const idsSet = toSet(ids)\n    idsSet.forEach(id => this.#pendingDecorations.get(id)?.abort())\n\n    const decorations = this.#getDecorations(idsSet)\n    if (decorations.length === 0) return\n\n    using disposables = new DisposableStack()\n\n    decorations.map(decoration => {\n      this.#decorations.delete(decoration.id)\n      disposables.use(decoration)\n    })\n    this.#canvasRenderer.remove(decorations)\n\n    this.#logger.verbose(`removed decorations ${decorations.map(d => d.id).join(', ')}`)\n  }\n\n  setVisibility(idsIterable: Iterable<TextDecorationId>, visible: boolean): void {\n    const ids = toSet(idsIterable)\n    this.#textRangeGeometryManager.setVisibility(\n      ids as Iterable<string> as Iterable<TextRangeGroupId>,\n      visible,\n    )\n    ids.forEach(id =>\n      visible ? this.#visibleDecorations.add(id) : this.#visibleDecorations.delete(id),\n    )\n\n    const decorations = this.#getDecorations(ids)\n    if (decorations.length === 0) return\n\n    // From here on, we update existing (non-pending) decorations\n\n    if (visible) {\n      // CanvasRenderer calls layout() on decoration render, which in turn registers interactive geometry.\n      // However, toggling visibility does not trigger layout(), so we need to re-register interative geometry here.\n      decorations.forEach(decoration => decoration.registerInteractiveGeometry())\n    } else {\n      decorations.forEach(decoration => decoration.removeInteractiveGeometry())\n    }\n    this.#canvasRenderer.setVisibility(decorations, visible)\n  }\n\n  removeHideAllReasons(reasons: readonly TextDecorationsHideReason[]): void {\n    if (reasons.length === 0) return\n\n    reasons.forEach(reason => this.#hideAllReasons.delete(reason))\n\n    if (this.#hideAllReasons.size > 0 || this.#decorations.size === 0) {\n      this.#inspector?.({\n        kind: 'updateAttributes',\n        id: this.#id,\n        attributes: { hidden: Array.from(this.#hideAllReasons).join(' ') },\n      })\n      this.#emitHideAllReasons(this.#hideAllReasons)\n    } else {\n      this.#inspector?.({\n        kind: 'updateAttributes',\n        id: this.#id,\n        attributes: { hidden: null },\n      })\n      this.#emitHideAllReasons(this.#hideAllReasons)\n      this.#interactiveGeometryManager.enablePointerEvents()\n      this.#textRangeGeometryManager.enableGeometryUpdate()\n      this.#canvasRenderer.showAllVisible()\n    }\n  }\n\n  addHideAllReasons(reasons: NonEmptyArray<TextDecorationsHideReason>): void {\n    const decorationsAlreadyHidden = this.#hideAllReasons.size > 0\n    reasons.forEach(reason => this.#hideAllReasons.add(reason))\n\n    this.#inspector?.({\n      kind: 'updateAttributes',\n      id: this.#id,\n      attributes: { hidden: Array.from(this.#hideAllReasons).join(' ') },\n    })\n    this.#emitHideAllReasons(this.#hideAllReasons)\n\n    if (decorationsAlreadyHidden || this.#decorations.size === 0) return\n\n    this.#interactiveGeometryManager.disablePointerEvents()\n    this.#textRangeGeometryManager.disableGeometryUpdate()\n    this.#canvasRenderer.hideAllVisible()\n  }\n\n  patchSegment(\n    id: TextDecorationId,\n    segmentId: TextDecorationSegmentId,\n    patch: Partial<SegmentPatchOptions>,\n  ): void {\n    const decoration = this.#decorations.get(id)\n    if (!decoration) return\n\n    decoration.patchSegment(segmentId, patch)\n    this.#canvasRenderer.requestRender([decoration])\n  }\n\n  focus(id: TextDecorationId | null): void {\n    this.#focusedDecorationId = id\n  }\n\n  #getDecorations(ids: Iterable<TextDecorationId>): CanvasTextDecoration[] {\n    return pipe(\n      ids,\n      map(id => this.#decorations.get(id)),\n      filter(isNonNullable),\n      toArray,\n    )\n  }\n\n  #handleGeometryChange(\n    documentGeometry: TextDocumentGeometryInfo,\n    devicePixelRatio: number,\n  ): void {\n    using _ = tracer.startSpan('CanvasTextDecorationManager.#handleGeometryChange()', {\n      attributes: { documentGeometry, devicePixelRatio },\n    })\n\n    this.#documentGeometry = documentGeometry\n\n    this.#inspector?.({\n      kind: 'updateAttributes',\n      id: this.#id,\n      attributes: {\n        style: `width: ${documentGeometry.documentFrame.width}px; height: ${documentGeometry.documentFrame.height}px; position: absolute; top: ${documentGeometry.documentFrame.y}px; left: ${documentGeometry.documentFrame.x}px;`,\n      },\n    })\n\n    const { visible } = this.#textRangeGeometryManager.pushDocumentGeometryChange(\n      documentGeometry.visibleTextRange,\n      documentGeometry.revision,\n    )\n\n    const visibleDecorations = pipe(\n      visible,\n      map(group => this.#decorations.get(group.metadata)),\n      filter(isNonNullable),\n      decorations => new Set(decorations),\n    )\n\n    this.#interactiveGeometryManager.clear()\n\n    this.#canvasRenderer.setViewport(\n      visibleDecorations,\n      ContentRect.create({\n        x: documentGeometry.scrollPosition?.x ?? 0,\n        y: documentGeometry.scrollPosition?.y ?? 0,\n        width: documentGeometry.documentFrame.width,\n        height: documentGeometry.documentFrame.height,\n      }),\n      devicePixelRatio,\n      {\n        text: this.#textRevisionSyncQueue.textRevision ?? TextRevision.initial,\n        geometry: documentGeometry.revision,\n      },\n    )\n\n    this.#logger.verbose('geometry changed', {\n      visibleTextRange: TextRange.toString(documentGeometry.visibleTextRange),\n    })\n  }\n\n  #updateMetrics(metrics?: Partial<TextDecorationMetrics>) {\n    this.#decorationMetrics.update(old => ({\n      ...old,\n      ...metrics,\n    }))\n  }\n\n  #contentPointToViewportPoint(contentPoint: PointLike): ViewportPoint {\n    return ViewportPoint.create({\n      x:\n        contentPoint.x -\n        (this.#documentGeometry?.scrollPosition?.x ?? 0) +\n        (this.#documentGeometry?.documentFrame.x ?? 0),\n      y:\n        contentPoint.y -\n        (this.#documentGeometry?.scrollPosition?.y ?? 0) +\n        (this.#documentGeometry?.documentFrame.y ?? 0),\n    })\n  }\n\n  #contentRectToViewportRect(contentRect: RectLike): ViewportRect {\n    return ViewportRect.create({\n      ...this.#contentPointToViewportPoint(contentRect),\n      width: contentRect.width,\n      height: contentRect.height,\n    })\n  }\n\n  #emitPointerEvent(events: PointerEvents<ContentRect, ComposedSegmentId>) {\n    this.#emitSegmentPointerEvents({\n      pointerEnter: this.#transformEvent(events.pointerEnter),\n      pointerLeave: this.#transformEvent(events.pointerLeave),\n      pointerDown: this.#transformEvent(events.pointerDown),\n      pointerUp: this.#transformEvent(events.pointerUp),\n      pointerClick: this.#transformEvent(events.pointerClick),\n    })\n  }\n\n  #transformEvent<Kind extends PointerEventKind>(\n    event?: PointerEvent<ContentRect, ComposedSegmentId, Kind>,\n  ): SegmentPointerEvent<Kind> | undefined {\n    if (!event) return undefined\n\n    const { decorationId, segmentId } = extractDecorationAndSegmentId(event.target)\n    const decoration = this.#decorations.get(decorationId)\n    const segmentRects = NonEmptyArray.from(\n      decoration?.segments?.find(s => s.id === segmentId)?.rects ?? [],\n    )\n    return !decoration || !segmentRects\n      ? undefined\n      : {\n          kind: event.kind,\n          segmentId,\n          id: decorationId,\n          position: this.#contentPointToViewportPoint(event.position),\n          rect: this.#contentRectToViewportRect(event.currentTarget),\n          decorationRects: decoration.rects.map(rect => this.#contentRectToViewportRect(rect)),\n        }\n  }\n\n  dispose() {\n    if (this.#disposables.disposed) return\n    this.#disposables.dispose()\n    this.#inspector?.({ kind: 'removeElement', id: this.#id })\n  }\n}\n",null,"import '@grammarly/util-polyfills'\nimport { exposeFromWorker } from '@grammarly/util-worker'\nimport * as api from \"/builds/qYDzyYR2/1/client-platform/inkwell/packages/feature-text-decoration/src/createCanvasTextDecorationManager.ts?comlink=api\"\nexposeFromWorker(api)"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","defaultCompare","n","m","z","s","sd","newLeft","newRight","t","i","j","swap","tmp","a","b","RBush","maxEntries","bbox","node","result","intersects","toBBox","nodesToSearch","child","childBBox","contains","data","tmpNode","item","createNode","equalsFn","path","indexes","parent","goingUp","index","findItem","items","height","N","M","calcBBox","N2","N1","multiSelect","right2","right3","level","minArea","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","yMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","p","destNode","minX","minY","maxX","maxY","children","stack","mid","InteractiveGeometryManager","options","__privateAdd","_InteractiveGeometryManager_instances","_logger","_disposables","_compareZIndex","_pointerPositionThrottleTimeMs","_geometryToRects","_rectToGeometry","_rectToZIndex","_upsertQueue","_removeQueue","_rTree","RTree","_getViewport","_emitMetrics","_flushQueue","__privateGet","createSingletonTaskQueue","__privateMethod","flushQueues_fn","microtaskScheduler","_nextZIndex","_enabled","_currentHoveredGeometry","_currentPointerDownGeometry","_pointerEventEmitter","Emitter","__publicField","__privateSet","logger","_a","throttledMouseMove","pipe","Rx","identity","position","handlePointerMove_fn","event","handlePointerDown_fn","handlePointerUp_fn","_b","_d","_c","geometry","rects","_stack","rectsToRemove","flatMap","toArray","rectsToUpdate","map","_","__using","tracer","rect","__privateWrapper","_error","_hasError","__callDispose","target","getTopMostIntersection_fn","events","isNonNullable","filter","intersections","equals","fn","x","mergeHorizontallyAdjacentRects","xAdjacencyEpsilon","yAdjacencyEpsilon","res","collatedR","rectsCount","nextR","nextRBottom","striclyAboveCollated","aboveCollated","equal","minLeft","minTop","maxRight","maxBottom","unionWidth","unionHeight","hasHorizontalOverlap","hasVerticalOverlap","degenerateRectAdjacentVertical","create","getLineBoundingBoxes","sortRectsTopToBottomLeftToRight","isGreater","isGreaterOrEqual","toString","text","TextRangeGeometryManager","_TextRangeGeometryManager_instances","_idSequence","IdSequence","_visibleTextRangePadding","_textRangeManager","_liveRangesToGroups","_idToGeometry","_visibleGeometry","_dirtyGeometry","_requestUpdateDirtyGeometry","_visibleTextRange","_revision","_geometryUpdateEnabled","_getRects","_getBoundingRects","TextRange.isCollapsed","TextRange.widen","TextRangeManager","requestGeometryForDirtyGroups_fn","id","geometryKind","metadata","revision","ranges","visible","liveRangesResult","Result.all","NonEmptyArray.map","range","updateSemantics","liveRanges","rangeGroup","DefaultLiveTextRangeGroupWithGeometry","minimumRevision","dirtyGeometryState","TextAndGeometryRevision.isGreater","enqueueGeometryUpdateFor_fn","disposeGroup_fn","liveRange","TextRange.intersect","Result.success","change","skipGeometryUpdate","getChangedRanges","affectedRanges","affectedGroups","r","dedupe","onScreenChangedGroups","takeWhile","group","NonEmptyArray.from","visibleTextRange","geometryRevision","onScreenGroups","TextRange.toString","g","textRangeGroupIds","newVisibleGeometry","dispose","groupsIterable","reason","force","groups","TextAndGeometryRevision.toString","textAndGeometryRevision","queuedRevision","separatedGroups","groupBy","groupsForRects","groupsForBoundingBoxes","rangesForRects","rangesForBoundingBoxes","defaultRectsResponse","defaultBoundingRectsResponse","rectsAndRevisions","boundingBoxesAndRevisions","NonEmptyArray.match","getRectsWithRetry_fn","getBoundingRectsWithRetry_fn","dirtyGeometry","TextAndGeometryRevision.isGreaterOrEqual","defaultValue","AsyncResult.retry","AsyncResult.mapError","sideEffect","error","AsyncResult.match","_metadata","_geometryKind","_ranges","_enqueueGetRects","_onDispose","_rects","TextRange.union","rectsState","AsyncResult.fromPromise","rectsAndRevision","createPrefixedCanvasInspector","prefix","inspector","message","createScopedCanvasInspector","parentId","transformObject","object","key","value","v","stepAnimation","animation","onDone","alpha","interpolate","UnreachableCaseError","start","end","duration","_drawDirtyRect","_drawViewport","_canvas","_ctx","_oversamplingFactor","_renderGenerators","_drawables","_onscreen","_hidden","_needsLayout","_needsRender","_toRemove","_useDirtyRects","_rtree","_emitRenderMetrics","_renderRequest","_viewportGeometry","_devicePixelRatio","_allHidden","_globalAlphaAnimation","_DefaultCanvasRenderer_instances","render_fn","getDrawablesToRender_fn","clearDirtyRectAndRenderDrawables_fn","renderDrawables_fn","calculateDirtyRectForRender_fn","layoutVisibleOnscreenDrawables_fn","DefaultCanvasRenderer","immediateRenderRequested","renderReasons","request","immediate","reasons","needsRender","drawables","drawable","onscreen","onscreenDrawables","viewport","devicePixelRatio","metrics","dirtyRect","scale","width","round","hasAnimatingDrawables","Rect.intersect","toSet","Rect.equals","animatingDrawables","sortedGenerators","renderGenerator","done","dirtyRects","Rect.isCollapsed","Rect.addPadding","Rect.unionOrElse","Rect.intersection","oldAndNewRects","visibleOnscreen","oldRect","oldAndNewRectsResolved","newRect","aRect","bRect","drawablesIterable","_interactiveGeometryManager","_rangesGroup","_isFocused","_segments","_boundingRect","_visibleRects","_zIndexTieBreaker","_zIndex","_inspector","_CanvasTextDecoration_instances","disposed_get","renderBackground_fn","renderUnderline_fn","createInspectorDOM_fn","updateInspectorDOM_fn","setInteractiveInInspectorDOM_fn","DEFAULT_UNDERLINE_ALIGNMENT","DEFAULT_UNDERLINE_THICKNESS","createComposedSegmentId","decorationId","segmentId","extractDecorationAndSegmentId","segmentIdentifier","zIndexTieBreaker","CanvasTextDecoration","segment","Rect.collapsed","interactive","underline","background","interactiveSegmentsChanged","updatedUnderline","updatedBackground","adjustRectToIncludeUnderlineAndEllipsis","extractBackgroundAnimation","extractUnderlineAnimation","zip","segments","ContentRect.map","ctx","hasAnimatingBackground","hasAnimatingUnderline","hasAnimatingSegments","running","underlineThickness","verticalOffset","underlineThicknessAndOffsetInLogicalPixels","lastRect","y","radius","gap","getEllipsisRadiusAndGap","oneTurn","decorationRect","segmentRect","backgroundPatch","underlinePatch","underlineRenderOptions","align","underlineOptions","extraHeight","ellipsis","extraWidth","_idSeq","_documentGeometry","_emitSegmentPointerEvents","_emitHideAllReasons","_textRangeGeometryManager","_decorations","_pointerMove","_pointerUp","_pointerDown","_pendingDecorations","_visibleOnscreenDecorations","_visibleDecorations","_focusedDecorationId","_decorationMetrics","_hideAllReasons","_canvasRenderer","_documentGeometryUpdateQueue","_textRevisionSyncQueue","_id","_DefaultCanvasTextDecorationManager_instances","getDecorations_fn","handleGeometryChange_fn","updateMetrics_fn","contentPointToViewportPoint_fn","contentRectToViewportRect_fn","emitPointerEvent_fn","transformEvent_fn","_DefaultCanvasTextDecorationManager","State","documentGeometry","TextRevisionSynchronizedQueue","_e","_f","_g","_h","_i","_j","_k","_l","_m","renderedVisibleOnscreenDecorations","visibleDecorations","allDecorations","setEqual","AsyncResult.map","rectAndGeoA","rectAndGeoB","decorationA","decorationB","segmentA","segmentB","scoreA","scoreB","hideAllReasons","visibleChanged","visibleChangedDecorations","TextRevision.initial","GeometryRevision.initial","d","abortController","rangesGroupResult","rangesGroup","decoration","ids","idsSet","decorations","disposables","idsIterable","decorationsAlreadyHidden","patch","old","contentPoint","ViewportPoint.create","contentRect","segmentRects","DefaultCanvasTextDecorationManager","createCanvasTextDecorationManager","proxy","exposeFromWorker","api"],"mappings":"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","x_google_ignoreList":[0,1]}