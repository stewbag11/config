{"version":3,"file":"Delta-Bv7tGR-CQrdco4K.js","sources":["../../../util-delta/dist/memoize-CBe7zL.mjs","../../../util-delta/dist/Operation-5s2blH.mjs","../../../util-delta/dist/removeTrailingRetainOp-BdlxFy.mjs","../../../util-delta/dist/Delta-Bv7tGR.mjs"],"sourcesContent":["function memoize(get, update = get) {\n    let value;\n    return {\n        get() {\n            if (value === undefined)\n                value = get();\n            return value;\n        },\n        update(p) {\n            if (value === undefined)\n                return;\n            value = update(p, this.get());\n        },\n        clear() {\n            value = undefined;\n        },\n    };\n}\n\nexport { memoize };\n//# sourceMappingURL=memoize-CBe7zL.mjs.map\n","/**\n * Is an operation a delete operation?\n * @public\n */\nfunction isDeleteOp(op) {\n    return op.delete !== undefined;\n}\n/**\n * Is an operation an insert operation?\n * @public\n */\nfunction isInsertOp(op) {\n    return op.insert !== undefined;\n}\n/**\n * Is an operation a retain operation?\n * @public\n */\nfunction isRetainOp(op) {\n    return op.retain !== undefined;\n}\n/**\n * Is an operation a text insert operation?\n * @public\n */\nfunction isTextInsertOp(op) {\n    return isInsertOp(op) && typeof op.insert === 'string';\n}\nfunction equalsOpAttributes(one, other) {\n    const a = one.attributes;\n    const b = other.attributes;\n    return shallowEquals(a, b);\n}\nfunction equalsOp(a, b) {\n    if (a === b)\n        return true;\n    if (a === undefined || b === undefined)\n        return false;\n    const ta = getOpType(a);\n    const tb = getOpType(a);\n    if (ta !== tb)\n        return false;\n    return shallowEquals(a[ta], b[tb]) && equalsOpAttributes(a, b);\n}\nfunction shallowEquals(a, b) {\n    if (a === b)\n        return true;\n    if (typeof a !== 'object' || typeof b !== 'object')\n        return false;\n    if (a === null || b === null)\n        return false;\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n        return false;\n    for (const key of keys) {\n        if (a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\n/**\n * Get the length of an operation (how many characters it affects).\n * @public\n */\nfunction getOpLength(op) {\n    // Let's check insert first as that's most common type of operation\n    if (isInsertOp(op)) {\n        return typeof op.insert === 'string' ? op.insert.length : 1;\n    }\n    else if (isRetainOp(op)) {\n        return op.retain;\n    }\n    else {\n        return op.delete;\n    }\n}\n/**\n * Get the type of an operation.\n * @public\n */\nfunction getOpType(op) {\n    if (isInsertOp(op)) {\n        return 'insert';\n    }\n    else if (isRetainOp(op)) {\n        return 'retain';\n    }\n    else {\n        return 'delete';\n    }\n}\nfunction cloneOp(op) {\n    return createOp({\n        ...op,\n        insert: isInsertOp(op)\n            ? typeof op.insert === 'object'\n                ? JSON.parse(JSON.stringify(op.insert))\n                : op.insert\n            : undefined,\n        attributes: op.attributes !== undefined ? { ...op.attributes } : op.attributes,\n    });\n}\nfunction createOp(op) {\n    // Always have same object structure.\n    // Monomorphic object structure is easier to optimize in JS engines.\n    return {\n        insert: op.insert,\n        delete: op.delete,\n        retain: op.retain,\n        attributes: op.attributes,\n    };\n}\nclass OperationIterator {\n    ops;\n    index;\n    offset;\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return this.peekLength() < Infinity;\n    }\n    next(length = Infinity) {\n        const nextOp = this.ops[this.index];\n        let operation;\n        if (nextOp !== undefined) {\n            const offset = this.offset;\n            const opLength = getOpLength(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (isDeleteOp(nextOp)) {\n                operation = createOp({ delete: length });\n            }\n            else if (isRetainOp(nextOp)) {\n                operation = { retain: length, attributes: nextOp.attributes };\n            }\n            else if (isTextInsertOp(nextOp)) {\n                operation = createOp({\n                    insert: nextOp.insert.slice(offset, offset + length),\n                    attributes: nextOp.attributes,\n                });\n            }\n            else {\n                operation = nextOp;\n            }\n        }\n        else {\n            operation = createOp({ retain: Infinity });\n        }\n        return operation;\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        const op = this.ops[this.index];\n        if (op !== undefined) {\n            // Should never return 0 if our index is being managed correctly\n            return getOpLength(op) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op !== undefined) {\n            return getOpType(op);\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nfunction withAttributes(op, attributes) {\n    if (attributes !== undefined && Object.keys(attributes).length > 0) {\n        return { ...op, attributes };\n    }\n    else {\n        return { ...op, attributes: undefined };\n    }\n}\n\nexport { OperationIterator, cloneOp, createOp, equalsOp, equalsOpAttributes, getOpLength, getOpType, isDeleteOp, isInsertOp, isRetainOp, isTextInsertOp, withAttributes };\n//# sourceMappingURL=Operation-5s2blH.mjs.map\n","import { isRetainOp } from './Operation-5s2blH.mjs';\n\nfunction removeTrailingRetainOp(delta) {\n    while (delta.ops.length > 0) {\n        const lastOp = delta.ops[delta.ops.length - 1];\n        if (lastOp !== undefined && isRetainOp(lastOp) && lastOp.attributes === undefined) {\n            const ops = delta.ops;\n            ops.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return delta;\n}\n\nexport { removeTrailingRetainOp };\n//# sourceMappingURL=removeTrailingRetainOp-BdlxFy.mjs.map\n","import { memoize } from './memoize-CBe7zL.mjs';\nimport { withAttributes, cloneOp, isDeleteOp, createOp, isInsertOp, equalsOpAttributes, isTextInsertOp, isRetainOp, OperationIterator, getOpLength, equalsOp } from './Operation-5s2blH.mjs';\nimport { removeTrailingRetainOp } from './removeTrailingRetainOp-BdlxFy.mjs';\n\n/**\n * A Delta is a list of operations (retain/insert/delete)\n * used to represent both documents and changes to documents.\n * @public\n */\nclass Delta {\n    _ops;\n    /** NOTE: This is change in text length. It can be negative too. */\n    _changeLength = memoize(() => this._ops.reduce((length, op) => {\n        if (isInsertOp(op)) {\n            return length + getOpLength(op);\n        }\n        else if (isDeleteOp(op)) {\n            return length - op.delete;\n        }\n        return length;\n    }, 0), (op, len) => {\n        if (isInsertOp(op))\n            return len + getOpLength(op);\n        else if (isDeleteOp(op))\n            return len - op.delete;\n        else\n            return len;\n    });\n    /**\n     * Get the operations array.\n     *\n     * @returns The operations array\n     */\n    get ops() {\n        return this._ops;\n    }\n    /**\n     * Get the length of the change.\n     *\n     * @returns The length of the change.\n     */\n    get changeLength() {\n        return this._changeLength.get();\n    }\n    constructor(init) {\n        this._ops = getOps(init);\n        if (this._ops.length === 0) {\n            // run memoize so it's updated on push()\n            this.changeLength;\n        }\n    }\n    /**\n     * Adds an insert operation to the delta.\n     *\n     * @param arg - The value to be inserted.\n     * @param attributes - Optional attributes for the operation.\n     * @returns The current delta object.\n     */\n    insert(arg, attributes) {\n        if (typeof arg === 'string' && arg.length === 0)\n            return this;\n        return this.push(withAttributes({ insert: arg }, attributes));\n    }\n    /**\n     * Adds a delete operation to the delta.\n     *\n     * @param arg - The value to be inserted.\n     * @param attributes - Optional attributes for the operation.\n     * @returns The current delta object.\n     */\n    delete(length) {\n        if (length <= 0)\n            return this;\n        return this.push({ delete: length });\n    }\n    /**\n     * Add a retain operation to the delta.\n     *\n     * @param arg - The value to be inserted.\n     * @param attributes - Optional attributes for the operation.\n     * @returns The current delta object.\n     */\n    retain(length, attributes) {\n        if (length <= 0)\n            return this;\n        return this.push(withAttributes({ retain: length }, attributes));\n    }\n    /**\n     * Pushes one or more operations to the delta.\n     *\n     * @param ops - The operations to be pushed into the delta.\n     * @returns The current delta object.\n     */\n    push(...ops) {\n        if (ops.length === 0)\n            return this;\n        const op = ops[0];\n        this._changeLength.update(op);\n        let index = this._ops.length;\n        let lastOp = this._ops[index - 1];\n        const newOp = cloneOp(op);\n        if (lastOp !== undefined) {\n            // Merge delete operation.\n            if (isDeleteOp(newOp) && isDeleteOp(lastOp)) {\n                this._ops[index - 1] = createOp({ delete: lastOp.delete + newOp.delete });\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (isDeleteOp(lastOp) && isInsertOp(newOp)) {\n                index -= 1;\n                lastOp = this._ops[index - 1];\n                if (lastOp === undefined) {\n                    this._ops.unshift(newOp);\n                    return this;\n                }\n            }\n            // Merge insert/retain operation\n            if (equalsOpAttributes(newOp, lastOp)) {\n                if (isTextInsertOp(newOp) && isTextInsertOp(lastOp)) {\n                    this._ops[index - 1] = createOp(withAttributes({ insert: lastOp.insert + newOp.insert }, newOp.attributes));\n                    return this;\n                }\n                else if (isRetainOp(newOp) && isRetainOp(lastOp)) {\n                    this._ops[index - 1] = createOp(withAttributes({ retain: lastOp.retain + newOp.retain }, newOp.attributes));\n                    return this;\n                }\n            }\n        }\n        if (index === this._ops.length) {\n            this._ops.push(newOp);\n        }\n        else {\n            this._ops.splice(index, 0, newOp);\n        }\n        if (ops.length > 1) {\n            const rest = ops.slice(1);\n            this._ops.push(...rest);\n            rest.forEach(op => {\n                this._changeLength.update(op);\n            });\n        }\n        return this;\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = new OperationIterator(this._ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += getOpLength(nextOp);\n        }\n        return new Delta(ops);\n    }\n    /**\n     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.\n     */\n    compose(other) {\n        return compose(this, new Delta(), other);\n    }\n    /**\n     * Transform a position against the delta. Useful for representing cursor/selection positions.\n     *\n     * @param position - position in text\n     * @param priority - if true, transformed position is kept closer to original position, otherwise position is moved with changes.\n     */\n    transformPosition(position, priority = false) {\n        const thisIter = new OperationIterator(this._ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= position) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                position -= Math.min(length, position - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (!priority || offset < position)) {\n                position += length;\n            }\n            offset += length;\n        }\n        return position;\n    }\n    toJSON() {\n        return JSON.stringify({ ops: this._ops });\n    }\n    toRaw() {\n        return { ops: this._ops };\n    }\n}\nfunction composeAttrs(a = {}, b = {}, preserveNull = false) {\n    const attributes = preserveNull ? { ...b } : {};\n    if (!preserveNull) {\n        for (const item of Object.entries(b)) {\n            if (item[1] !== null) {\n                attributes[item[0]] = item[1];\n            }\n        }\n    }\n    // Take properties from a where b is undefined\n    for (const key of Object.keys(a)) {\n        if (a[key] !== undefined && b[key] === undefined) {\n            attributes[key] = a[key];\n        }\n    }\n    return Object.keys(attributes).length > 0 ? attributes : undefined;\n}\nfunction getOps(init) {\n    if (!init)\n        return [];\n    if (isReadonlyArray(init))\n        return init.slice();\n    return init.ops.slice();\n}\nfunction isReadonlyArray(value) {\n    return Array.isArray(value);\n}\nfunction compose(current, next, changes) {\n    const thisIter = new OperationIterator(current.ops);\n    const otherIter = new OperationIterator(changes.ops);\n    const firstOther = otherIter.peek();\n    if (firstOther !== undefined && isRetainOp(firstOther) && firstOther.attributes === undefined) {\n        let firstLeft = firstOther.retain;\n        while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n            firstLeft -= thisIter.peekLength();\n            next.push(thisIter.next());\n        }\n        if (firstOther.retain - firstLeft > 0) {\n            otherIter.next(firstOther.retain - firstLeft);\n        }\n    }\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n        if (otherIter.peekType() === 'insert') {\n            next.push(otherIter.next());\n        }\n        else if (thisIter.peekType() === 'delete') {\n            next.push(thisIter.next());\n        }\n        else {\n            const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n            const thisOp = thisIter.next(length);\n            const otherOp = otherIter.next(length);\n            if (isRetainOp(otherOp)) {\n                let newOp;\n                if (isRetainOp(thisOp)) {\n                    newOp = { retain: length };\n                }\n                else {\n                    newOp = { insert: thisOp.insert };\n                }\n                // Preserve null when composing with a retain, otherwise remove it for inserts\n                next.push(withAttributes(newOp, composeAttrs(thisOp.attributes, otherOp.attributes, isRetainOp(thisOp))));\n                // Optimization if rest of other is just retain\n                if (!otherIter.hasNext() && equalsOp(next.ops[next.ops.length - 1], newOp)) {\n                    return removeTrailingRetainOp(next.push(...thisIter.rest()));\n                }\n                // Other op should be delete, we could be an insert or retain\n                // Insert + delete cancels out\n            }\n            else if (isDeleteOp(otherOp) && isRetainOp(thisOp)) {\n                next.push(otherOp);\n            }\n        }\n    }\n    return removeTrailingRetainOp(next);\n}\n\nexport { Delta, compose, getOps };\n//# sourceMappingURL=Delta-Bv7tGR.mjs.map\n"],"names":["memoize","get","update","value","p","isDeleteOp","op","isInsertOp","isRetainOp","isTextInsertOp","equalsOpAttributes","one","other","a","b","shallowEquals","equalsOp","ta","getOpType","tb","keys","key","getOpLength","cloneOp","createOp","OperationIterator","ops","__publicField","length","nextOp","operation","offset","opLength","index","next","rest","withAttributes","attributes","removeTrailingRetainOp","delta","lastOp","Delta","init","len","getOps","arg","newOp","start","end","iter","compose","position","priority","thisIter","nextType","composeAttrs","preserveNull","item","isReadonlyArray","current","changes","otherIter","firstOther","firstLeft","thisOp","otherOp"],"mappings":"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"}