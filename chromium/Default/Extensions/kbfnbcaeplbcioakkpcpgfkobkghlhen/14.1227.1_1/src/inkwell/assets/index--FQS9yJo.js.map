{"version":3,"file":"index--FQS9yJo.js","sources":["../../../util-capi-client/dist/CAPIClient-CuXRCp.mjs","../../../feature-capi/src/index.ts"],"sourcesContent":["import { dispose } from '@grammarly/util-disposable';\nimport { UnreachableCaseError, CustomError } from '@grammarly/util-error';\nimport { pipe, sideEffect, constVoid } from '@grammarly/util-function';\nimport { logger } from '@grammarly/util-logging';\nimport { Emitter, State, SubscribableState } from '@grammarly/util-reactive';\nimport { AsyncResult } from '@grammarly/util-result';\n\n/**\n * CAPIClient is a client that communicates with the CAPI server.\n * @public\n */\nclass CAPIClient {\n    #emitter = new Emitter();\n    #status = new State({ kind: 'disconnected', sessionId: null });\n    #transportFactory;\n    #options;\n    #disposables = new DisposableStack();\n    #queue = [];\n    #pendingRequests = new Map();\n    constructor(transportFactory, options) {\n        this.#disposables.defer(() => dispose(transportFactory));\n        this.#transportFactory = transportFactory;\n        this.#options = options;\n        this.#disposables.defer(() => {\n            const state = this.#status.getValue();\n            if (state.kind === 'connecting') {\n                state.controller.abort();\n            }\n            this.#status.setValue({\n                kind: 'disconnected',\n                sessionId: 'sessionId' in state ? state.sessionId : null,\n            });\n        });\n    }\n    [Symbol.dispose]() {\n        this.#disposables.dispose();\n    }\n    connect() {\n        if (this.#disposables.disposed) {\n            return logger.warn('Cannot connect after the CAPIClient was disposed.');\n        }\n        const state = this.#status.getValue();\n        if (state.kind === 'connecting' || state.kind === 'connected') {\n            return; // already connecting or connected\n        }\n        const previousSessionId = 'sessionId' in state ? state.sessionId : null;\n        const controller = new AbortController();\n        void pipe(this.#transportFactory.create({ ...this.#options, previous: state.transport }), sideEffect(transport => this.#status.setValue({ kind: 'connecting', transport, controller })), AsyncResult.map(transport => {\n            if (controller.signal.aborted) {\n                return dispose(transport);\n            }\n            this.#status.setValue({\n                kind: 'connected',\n                transport,\n                sessionId: transport.sessionId,\n                isNewSession: transport.sessionId !== previousSessionId,\n            });\n            // Flush queues when we transition to 'connected'\n            this.#flush();\n            let hasError = false;\n            const disposables = new DisposableStack();\n            this.#disposables.use(disposables);\n            disposables.use(transport);\n            disposables.use(transport.onDidReceive.subscribe(event => {\n                const onReceive = this.#pendingRequests.get(event.id);\n                if (onReceive) {\n                    this.#pendingRequests.delete(event.id);\n                    onReceive.resolve(event);\n                }\n                this.#emitter.emit(event);\n            }));\n            disposables.use(transport.onDidError.subscribe(error => {\n                hasError = true;\n                this.#status.update(state => ({\n                    kind: 'error',\n                    error,\n                    transport,\n                    sessionId: 'sessionId' in state ? state.sessionId : null,\n                }));\n            }));\n            disposables.use(transport.onDidClose.subscribe(() => {\n                const sessionId = pipe(this.#status.getValue(), state => 'sessionId' in state ? state.sessionId : null);\n                const error = new CAPIConnectionClosedError(sessionId);\n                // reject all pending requests\n                this.#pendingRequests.forEach(onReceive => onReceive.reject(error));\n                this.#pendingRequests.clear();\n                // reject all queued requests\n                this.#queue.forEach(({ onSend, onReceive }) => {\n                    onSend.reject(error);\n                    onReceive?.reject(error);\n                });\n                this.#queue.length = 0;\n                disposables.dispose();\n                if (!hasError) {\n                    this.#status.setValue({\n                        kind: 'disconnected',\n                        transport,\n                        sessionId,\n                    });\n                }\n            }));\n        }), AsyncResult.mapError(sideEffect(error => {\n            if (controller.signal.aborted)\n                return;\n            this.#status.update(state => ({\n                kind: 'error',\n                error,\n                sessionId: 'sessionId' in state ? state.sessionId : null,\n            }));\n        })));\n    }\n    get onEvent() {\n        return this.#emitter;\n    }\n    get status() {\n        return pipe(this.#status, SubscribableState.map(status => {\n            switch (status.kind) {\n                case 'connecting':\n                    return { kind: 'connecting' };\n                case 'connected':\n                    return {\n                        kind: 'connected',\n                        sessionId: status.sessionId,\n                        isNewSession: status.isNewSession,\n                    };\n                case 'disconnected':\n                    return { kind: 'disconnected', sessionId: status.sessionId };\n                case 'error':\n                    return { kind: 'error', sessionId: status.sessionId };\n                default:\n                    throw new UnreachableCaseError(status);\n            }\n        }));\n    }\n    toString() {\n        const state = this.#status.getValue();\n        switch (state.kind) {\n            case 'connecting':\n                return `Client(connecting)`;\n            case 'connected':\n                return `Client(connected: ${state.transport})`;\n            case 'disconnected':\n                return `Client(disconnected)`;\n            case 'error':\n                return `Client(error: ${state.error.message})`;\n        }\n    }\n    send(message, signal) {\n        const onSend = Promise.withResolvers();\n        return this.#send(message, onSend, undefined, signal);\n    }\n    sendAndAwaitResponse(message, signal) {\n        const onSend = Promise.withResolvers();\n        const onReceive = Promise.withResolvers();\n        return pipe(this.#send(message, onSend, onReceive, signal), AsyncResult.flatMap(() => AsyncResult.fromPromise(onReceive.promise)));\n    }\n    // Sends a message and waits for message to be sent. Does not wait for a response to be received.\n    #send(message, onSend, onReceive, signal) {\n        this.#queue.push({ message, onSend, onReceive, signal });\n        this.#flush();\n        return pipe(AsyncResult.fromPromise(onSend.promise), AsyncResult.map(constVoid));\n    }\n    #flush() {\n        const state = this.#status.getValue();\n        if (state.kind !== 'connected')\n            return;\n        this.#queue.forEach(({ message, onSend, onReceive, signal }) => {\n            if (signal?.aborted) {\n                onSend.reject(new MessageAbortError());\n                onReceive?.reject(new MessageAbortError());\n                return;\n            }\n            const id = state.transport.send(message);\n            if (id === undefined && onReceive) {\n                logger.warn('onReceive callbacks are not supported by this transport');\n            }\n            else if (onReceive) {\n                this.#pendingRequests.set(id, onReceive);\n            }\n            Reflect.set(message, 'id', id);\n            onSend.resolve(message);\n        });\n        this.#queue.length = 0;\n    }\n}\n/**\n * Error thrown when the operation is aborted.\n * @public\n */\nclass MessageAbortError extends CustomError {\n    constructor() {\n        super('Message aborted');\n    }\n}\n/**\n * Connection closed error.\n * @public\n */\nclass CAPIConnectionClosedError extends CustomError {\n    constructor(capiSessionId) {\n        super(`CAPI Connection closed (SessionId: ${capiSessionId})`);\n    }\n}\n\nexport { CAPIClient, CAPIConnectionClosedError, MessageAbortError };\n//# sourceMappingURL=CAPIClient-CuXRCp.mjs.map\n","/**\n * This features provides access to CAPI connections.\n * @packageDocumentation\n */\n\nimport type { Activate, ExecutionScopeDefinition, FeatureContext } from '@grammarly/feature'\nimport { CAPIClient, CAPIProviderToken, type CAPIConnection } from '@grammarly/util-capi-client'\nimport { createInjectionToken, Lifetime } from '@grammarly/util-dependency-container'\nimport { pipe } from '@grammarly/util-function'\nimport { AsyncResult, Result, ResultDisposable } from '@grammarly/util-result'\nimport { Rx } from '@grammarly/util-reactive'\n\nimport type {} from '@grammarly/feature-document-session'\n\n/**\n * A client to CAPI WebSocket server.\n * @public\n */\nexport const CAPIConnectionToken = createInjectionToken<CAPIConnection>(Symbol('CAPIConnection'))\n\n/** @public */\nexport const activate: Activate = context =>\n  pipe(\n    context.getExecutionScope('document-session'),\n    Result.flatMap(documentSessionScope =>\n      ResultDisposable.all([\n        ...registerDependencies(context, documentSessionScope),\n        // Connect to CAPI on document session start and disconnects.\n        Result.success(\n          documentSessionScope.onStart(execution =>\n            pipe(\n              execution.resolve(CAPIClient),\n              Result.map(client => {\n                client.connect()\n\n                // Handle reconnects\n                return pipe(\n                  Rx.fromSubscribable(client.status),\n                  Rx.pairwise(),\n                  Rx.filter(\n                    ([prev, next]) => prev.kind === 'connected' && next.kind === 'disconnected',\n                  ),\n                  Rx.subscribe(() =>\n                    // TODO:(before-capi-migration) We should handle reconnection more gracefully when we move CAPI socket to InkWell side.\n                    client.connect(),\n                  ),\n                )\n              }),\n              AsyncResult.fromResult,\n            ),\n          ),\n        ),\n      ]),\n    ),\n  )\n\nfunction registerDependencies(\n  context: FeatureContext,\n  documentSessionScope: ExecutionScopeDefinition<'document-session'>,\n) {\n  return [\n    // Provide CAPI connection to the document session.\n    pipe(\n      context.getFeature('document-session'),\n      Result.flatMap(documentSessionFeature =>\n        documentSessionScope.register(\n          {\n            token: CAPIClient,\n            useFactory: resolver =>\n              pipe(\n                Result.all([\n                  resolver.resolve(CAPIProviderToken),\n                  resolver.resolve(documentSessionFeature.provides.TextDocument),\n                ] as const),\n                Result.map(\n                  ([provider, document]) =>\n                    new CAPIClient(provider.create(document.id), { documentId: document.id }),\n                ),\n              ),\n          },\n          {\n            lifetime: Lifetime.ContainerScoped,\n          },\n        ),\n      ),\n    ),\n    // Alias CAPIConnection to CAPIClient.\n    documentSessionScope.register({ token: CAPIConnectionToken, useToken: CAPIClient }),\n  ]\n}\n"],"names":["CAPIClient","transportFactory","options","__privateAdd","_CAPIClient_instances","_emitter","Emitter","_status","State","_transportFactory","_options","_disposables","_queue","_pendingRequests","__privateGet","dispose","__privateSet","state","logger","previousSessionId","controller","pipe","sideEffect","transport","AsyncResult.map","__privateMethod","flush_fn","hasError","disposables","event","onReceive","error","sessionId","CAPIConnectionClosedError","onSend","AsyncResult.mapError","SubscribableState.map","status","UnreachableCaseError","message","signal","send_fn","AsyncResult.flatMap","AsyncResult.fromPromise","constVoid","MessageAbortError","id","CustomError","capiSessionId","CAPIConnectionToken","createInjectionToken","activate","context","Result.flatMap","documentSessionScope","ResultDisposable","registerDependencies","Result.success","execution","Result.map","client","Rx","prev","next","AsyncResult.fromResult","resolver","Result.all","CAPIProviderToken","documentSessionFeature","provider","document","Lifetime"],"mappings":"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"}