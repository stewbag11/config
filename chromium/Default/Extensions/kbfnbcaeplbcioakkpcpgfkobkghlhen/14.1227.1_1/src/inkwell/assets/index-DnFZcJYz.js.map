{"version":3,"file":"index-DnFZcJYz.js","sources":["../../../feature-document-session/src/TextDocument.ts","../../../feature-document-session/src/DocumentSession.ts","../../../feature-document-session/src/DocumentSessionManager.ts","../../../feature-document-session/src/dependencies.ts","../../../feature-document-session/src/index.ts"],"sourcesContent":["import type {\n  ConnectorID,\n  DocumentID,\n  RemoteDocument,\n  RemoteDocumentGeometryInfo,\n} from '@grammarly/feature-connector'\nimport type { Monitoring } from '@grammarly/feature-monitoring'\nimport type { DocumentGeometryChangeReason } from '@grammarly/util-connector-protocol'\nimport { Delta, type InsertOperation } from '@grammarly/util-delta'\nimport { pipe, sideEffect } from '@grammarly/util-function'\nimport {\n  GeometryRevision,\n  type DocumentViewportRect,\n  type TextAndGeometryRevision,\n} from '@grammarly/util-geometry'\nimport { isDev } from '@grammarly/util-is-dev'\nimport { logger, type Logger } from '@grammarly/util-logging'\nimport {\n  Emitter,\n  Rx,\n  State,\n  timeoutWith,\n  type Subscribable,\n  type SubscribableState,\n} from '@grammarly/util-reactive'\nimport { AutomaticRefCounted, type RefCounted } from '@grammarly/util-ref-counted'\nimport { AsyncResult, Result } from '@grammarly/util-result'\nimport { RandomUserSampler } from '@grammarly/util-sampling'\nimport {\n  TextRevision,\n  type TextChange,\n  type TextContent,\n  type TextRange,\n} from '@grammarly/util-text'\n\nexport type { DocumentID } from '@grammarly/feature-connector'\n\n/**\n * Geometry information for a text document.\n * @public\n */\nexport interface TextDocumentGeometryInfo extends RemoteDocumentGeometryInfo {\n  /**\n   * Geometry revision associated to the document geometry.\n   * This is incremented:\n   * - on every geometry-did-change message we receive\n   * - whenever the field gains focus\n   * - and when we timeout due to not getting geometry-did-change after geometry-will-change\n   */\n  readonly revision: GeometryRevision\n}\n\n/**\n * Geometry information and state for a text document.\n * @public\n */\nexport interface ExtendedTextDocumentGeometryInfo {\n  /**\n   * Document geometry or null when unknown.\n   */\n  readonly geometry: TextDocumentGeometryInfo | null\n  /**\n   * True if the document is being scrolled.\n   */\n  readonly documentFrameScrolling: boolean\n  /**\n   * True if the window is being resized.\n   */\n  readonly windowFrameResizing: boolean\n  /**\n   * True if the window is being moved.\n   */\n  readonly windowFrameMoving: boolean\n}\n\n/**\n * Event sent when the document geometry will change\n * @public\n */\nexport interface TextDocumentGeometryWillChangeEvent\n  extends Pick<\n    ExtendedTextDocumentGeometryInfo,\n    'documentFrameScrolling' | 'windowFrameResizing' | 'windowFrameMoving'\n  > {\n  readonly reasons: ReadonlySet<DocumentGeometryChangeReason>\n}\n\n/**\n * Response to TextDocument.getRects()\n * @public\n */\nexport interface GetRectsResponse<Id extends string> {\n  readonly rects: Map<Id, DocumentViewportRect[]>\n  readonly revision: TextAndGeometryRevision\n}\n\n/**\n * Response to TextDocument.getBoundingRects()\n * @public\n */\nexport interface GetBoundingRectsResponse<Id extends string> {\n  readonly rects: Map<Id, DocumentViewportRect>\n  readonly revision: TextAndGeometryRevision\n}\n\n/**\n * A representation of a remote document with caching\n * and asynchronous data fetching.\n *\n * @public\n */\nexport interface TextDocument {\n  /**\n   * Document identifier\n   */\n  readonly id: DocumentID\n  /**\n   * Connector connection identifier\n   */\n  // TODO: This can become stale after a reconnect, should it be a SubscribableState?\n  readonly connectorId: ConnectorID\n  /**\n   * State representing the current text content.\n   */\n  readonly text: SubscribableState<TextContent>\n\n  /**\n   * Event that notifies when the text changes.\n   * The event includes the text change and the revision number.\n   */\n  readonly onTextDidChange: Subscribable<RefCounted<TextChange>>\n  /**\n   * State representing the current document geometry.\n   */\n  readonly geometry: SubscribableState<ExtendedTextDocumentGeometryInfo>\n  /**\n   * Event emitted when the document geometry is about to change.\n   */\n  readonly geometryWillChange: Subscribable<TextDocumentGeometryWillChangeEvent>\n  /**\n   * State representing the current text selection.\n   */\n  readonly selection: SubscribableState<TextRange[]>\n  /**\n   * SubscribableState that holds the document focus state\n   */\n  readonly hasFocus: SubscribableState<boolean>\n  /**\n   * Set the text of the document.\n   * @param text - The new text\n   */\n  setText(text: TextChange): AsyncResult<void>\n  /**\n   * Set the selection of the document.\n   * @param ranges - The text ranges that should be selected\n   */\n  setSelection(ranges: readonly TextRange[]): AsyncResult<void>\n  /**\n   * Get the rectangles that bound the given text ranges. Each text range can be bound by one or more rectangles.\n   * @param ranges - The text ranges for which rectangles should be calculated\n   */\n  getRects<Id extends string>(ranges: ReadonlyMap<Id, TextRange>): AsyncResult<GetRectsResponse<Id>>\n  /**\n   * Get the bounding boxes for the given text ranges.\n   * @param ranges - The text ranges for which bounding boxes should be calculated\n   */\n  getBoundingRects<Id extends string>(\n    ranges: ReadonlyMap<Id, TextRange>,\n  ): AsyncResult<GetBoundingRectsResponse<Id>>\n}\n\nexport class DefaultTextDocument implements TextDocument, Disposable {\n  readonly #logger: Logger\n  readonly #disposables = new DisposableStack()\n  readonly #text = new State<TextContent>({\n    revision: TextRevision.initial,\n    content: new Delta<InsertOperation>(),\n  })\n  readonly #selection = new State<TextRange[]>([])\n  readonly #sampler = new RandomUserSampler({ probability: 0.01 })\n\n  #windowFrameMoving = false\n  #windowFrameResizing = false\n  #documentFrameScrolling = false\n\n  readonly #geometry = new State<ExtendedTextDocumentGeometryInfo>({\n    geometry: null,\n    windowFrameMoving: false,\n    windowFrameResizing: false,\n    documentFrameScrolling: false,\n  })\n  readonly #geometryWillChange = new Emitter<TextDocumentGeometryWillChangeEvent>()\n  readonly #hasFocus = new State<boolean>(false)\n  readonly #onTextDidChange = new Emitter<RefCounted<TextChange>>()\n  // TODO: Not used, remove?\n  readonly #history: Array<AutomaticRefCounted<TextChange>> = []\n  readonly #monitoring: Monitoring\n  readonly #counters = {\n    getRects: 0,\n    getBoundingRects: 0,\n  }\n  readonly #document: RemoteDocument\n\n  constructor(document: RemoteDocument, monitoring: Monitoring) {\n    this.#document = document\n    this.#monitoring = monitoring\n    this.#logger = logger.createLogger('TextDocument', document.id)\n    // Get the initial text value\n    const onDidInit = timeoutWith(\n      pipe(\n        document.getText(),\n        AsyncResult.map(text => {\n          this.#text.setValue(text)\n          const refCounted = new AutomaticRefCounted({\n            revision: text.revision,\n            change: text.content,\n          })\n          this.#history.push(refCounted)\n          this.#onTextDidChange.emit(refCounted)\n        }),\n        AsyncResult.mapError(\n          sideEffect(error => {\n            this.#logger.error('Unexpected error when fetching initial text', error)\n          }),\n        ),\n      ),\n      {\n        timeoutMs: 5000,\n        defaultValue: Result.success(),\n        onTimeout: () => {\n          this.#logger.warn('Did not receive initial text within 5s.')\n        },\n      },\n    )\n\n    this.#disposables.use(\n      pipe(\n        Rx.fromSubscribable(document.onTextDidChange),\n        Rx.bufferUntil(onDidInit),\n        Rx.subscribe(textChange => {\n          const previous = this.#text.getValue()\n          if (textChange.revision <= previous.revision) return // ignore outdated changes\n          const next = previous.content.compose(textChange.change) as Delta<InsertOperation>\n          this.#text.setValue({ revision: textChange.revision, content: next })\n          const refCounted = new AutomaticRefCounted(textChange)\n          this.#history.push(refCounted)\n          this.#onTextDidChange.emit(refCounted)\n          queueMicrotask(() => this.#purgeHistory())\n        }),\n      ),\n    )\n\n    this.#disposables.use(\n      document.onSelectionDidChange.subscribe(ranges =>\n        this.#selection.setValue(Array.from(ranges)),\n      ),\n    )\n\n    const geometryWillChange = Rx.fromSubscribable(document.onGeometryWillChange).pipe(Rx.share())\n    const geometryDidChange = Rx.fromSubscribable(document.onGeometryDidChange).pipe(Rx.share())\n\n    // Set reasons on will-change\n    this.#disposables.use(\n      pipe(\n        geometryWillChange,\n        Rx.subscribe(reasons => {\n          this.#documentFrameScrolling = reasons.has('DocumentFrameScrolled')\n            ? true\n            : this.#documentFrameScrolling\n          this.#windowFrameResizing = reasons.has('WindowFrameChanged')\n            ? true\n            : this.#windowFrameResizing\n          this.#windowFrameMoving = reasons.has('WindowFrameChanged')\n            ? true\n            : this.#windowFrameMoving\n          this.#geometryWillChange.emit({\n            reasons,\n            documentFrameScrolling: this.#documentFrameScrolling,\n            windowFrameResizing: this.#windowFrameResizing,\n            windowFrameMoving: this.#windowFrameMoving,\n          })\n        }),\n      ),\n    )\n\n    // Reset reasons on did-change\n    this.#disposables.use(\n      pipe(\n        geometryDidChange,\n        Rx.subscribe(reasons => {\n          this.#documentFrameScrolling = reasons.has('DocumentFrameScrolled')\n            ? false\n            : this.#documentFrameScrolling\n          this.#windowFrameMoving = reasons.has('WindowFrameChanged')\n            ? false\n            : this.#windowFrameMoving\n          this.#windowFrameResizing = reasons.has('WindowFrameChanged')\n            ? false\n            : this.#windowFrameResizing\n        }),\n      ),\n    )\n\n    // Reset reasons on blur\n    this.#disposables.use(\n      document.hasFocus.subscribe(focused => {\n        this.#hasFocus.setValue(focused)\n        if (!focused) {\n          this.#documentFrameScrolling = false\n          this.#windowFrameMoving = false\n          this.#windowFrameResizing = false\n\n          this.#geometry.update(state => ({\n            ...state,\n            windowFrameMoving: this.#windowFrameMoving,\n            windowFrameResizing: this.#windowFrameResizing,\n            documentFrameScrolling: this.#documentFrameScrolling,\n          }))\n        }\n      }),\n    )\n\n    // Observable that emits if did-change is not received in time after will-change.\n    const geometryDidChangeAfterWillChangeTimeout = pipe(\n      geometryWillChange,\n      Rx.switchMap(() => {\n        // Use a bigger timeout when the window is moving/resizing\n        const timeoutMs = this.#windowFrameMoving || this.#windowFrameResizing ? 2000 : 1000\n        // If the first did-change after a will-change is not emitted after some timeout, emit null\n        return pipe(\n          geometryDidChange,\n          Rx.take(1),\n          Rx.timeout({ first: timeoutMs, with: () => Rx.of(null) }),\n          // Only emit values coming from the timeout\n          Rx.filter(value => value === null),\n          Rx.tap(() => {\n            if (isDev) {\n              this.#logger.warn(\n                `Did not receive documentGeometryDidChange event after ${timeoutMs / 1000}s. Triggering geometry update.`,\n              )\n            }\n          }),\n        )\n      }),\n    )\n\n    let geometryRevision = GeometryRevision.initial\n    const retryGetGeometryOnFailure = new Rx.Subject<void>()\n    let retryCount = 0\n\n    this.#disposables.use(\n      pipe(\n        // Emit whenever focus changes or we receive geometry-did-change,\n        // or when we did not receive geometry-did-change after some timeout elapsed following geometry-will-change\n        Rx.merge(\n          Rx.fromSubscribableState(document.hasFocus),\n          geometryDidChange,\n          geometryDidChangeAfterWillChangeTimeout,\n          retryGetGeometryOnFailure,\n        ),\n        Rx.tap(() => {\n          // The geometry revision is incremented:\n          // - on every geometry-did-change message we receive\n          // - whenever the field gains focus\n          // - and when we timeout due to not getting geometry-did-change after geometry-will-change\n          geometryRevision = GeometryRevision.create(geometryRevision + 1)\n        }),\n        // Only request geometry when the document is focused\n        Rx.filter(() => document.hasFocus.getValue()),\n        // Get the document geometry\n        Rx.exhaustMapWithTrailing(async (_, index) => {\n          await using monitor = monitoring.duration('get_geometry', {\n            labels: { request_kind: index === 0 ? 'initial' : 'other' },\n            sampler: this.#sampler,\n          })\n\n          return await pipe(\n            document.getGeometry(),\n            AsyncResult.mapError(sideEffect(error => monitor.close(error))),\n          )\n        }),\n        Rx.subscribe(\n          Result.match({\n            success: geometry => {\n              retryCount = 0\n              this.#geometry.setValue({\n                geometry: { ...geometry, revision: geometryRevision },\n                windowFrameMoving: this.#windowFrameMoving,\n                windowFrameResizing: this.#windowFrameResizing,\n                documentFrameScrolling: this.#documentFrameScrolling,\n              })\n            },\n            failure: error => {\n              this.#logger.error('Unexpected error when fetching document geometry', error)\n              if (this.#hasFocus.getValue() && retryCount < 3) {\n                retryCount++\n                retryGetGeometryOnFailure.next()\n              } else {\n                this.#monitoring.count('get_geometry_aborted')\n              }\n            },\n          }),\n        ),\n      ),\n    )\n  }\n\n  #purgeHistory() {\n    while (this.#history.at(0)?.inUse === false) {\n      this.#history.shift()\n    }\n\n    if (this.#history.length > 1000) {\n      this.#logger.warn('Document history is too long.')\n    }\n  }\n\n  get onTextDidChange(): Subscribable<RefCounted<TextChange>> {\n    return this.#onTextDidChange\n  }\n\n  get id(): DocumentID {\n    return this.#document.id\n  }\n\n  get connectorId(): ConnectorID {\n    return this.#document.connectorId\n  }\n\n  get text(): SubscribableState<TextContent> {\n    return this.#text\n  }\n\n  get selection(): SubscribableState<TextRange[]> {\n    return this.#selection\n  }\n\n  get geometry(): SubscribableState<ExtendedTextDocumentGeometryInfo> {\n    return this.#geometry\n  }\n\n  get geometryWillChange(): Subscribable<TextDocumentGeometryWillChangeEvent> {\n    return this.#geometryWillChange\n  }\n\n  get hasFocus(): SubscribableState<boolean> {\n    return this.#hasFocus\n  }\n\n  setText(text: TextChange): AsyncResult<void> {\n    return this.#document.setText(text)\n  }\n\n  setSelection(ranges: readonly TextRange[]): AsyncResult<void> {\n    return this.#document.setSelection(this.#text.getValue().revision, ranges)\n  }\n\n  #getCountGroup(count: number): string {\n    const bucket = Math.ceil(count / 10)\n    return bucket.toString()\n  }\n\n  async getRects<Id extends string>(\n    ranges: ReadonlyMap<Id, TextRange>,\n  ): AsyncResult<GetRectsResponse<Id>> {\n    const geometry = this.#geometry.getValue().geometry\n    if (!geometry) {\n      this.#logger.warn('Calling TextDocument.getRects() with no geometry revision yet')\n    }\n\n    const textRevision = this.#text.getValue().revision\n    const geometryRevision = geometry?.revision ?? GeometryRevision.initial\n\n    await using monitor = this.#monitoring.duration('get_rects', {\n      labels: {\n        request_kind: this.#counters.getRects === 0 ? 'initial' : 'other',\n        bucket_size: this.#getCountGroup(ranges.size),\n      },\n      sampler: this.#sampler,\n    })\n    this.#counters.getRects++\n    return await pipe(\n      this.#document.getRectsForRanges(textRevision, ranges),\n      AsyncResult.map(({ rects, textRevision: text }) => ({\n        rects,\n        revision: { text, geometry: geometryRevision },\n      })),\n      AsyncResult.mapError(\n        sideEffect(error => {\n          monitor.close(error)\n          this.#logger.error(\n            'Unexpected error when calling RemoteDocument.getRectsForRanges()',\n            error,\n          )\n        }),\n      ),\n    )\n  }\n\n  async getBoundingRects<Id extends string>(\n    ranges: ReadonlyMap<Id, TextRange>,\n  ): AsyncResult<GetBoundingRectsResponse<Id>> {\n    const geometry = this.#geometry.getValue().geometry\n    if (!geometry) {\n      this.#logger.warn('Calling TextDocument.getBoundingRects() with no geometry revision yet')\n    }\n\n    const geometryRevision = geometry?.revision ?? GeometryRevision.initial\n    await using monitor = this.#monitoring.duration('get_bounding_rects', {\n      labels: {\n        request_kind: this.#counters.getBoundingRects === 0 ? 'initial' : 'other',\n        bucket_size: this.#getCountGroup(ranges.size),\n      },\n      sampler: this.#sampler,\n    })\n    this.#counters.getBoundingRects++\n\n    return await pipe(\n      this.#document.getBoundingRectForRanges(this.#text.getValue().revision, ranges),\n      AsyncResult.map(({ rects, textRevision: text }) => ({\n        rects,\n        revision: { text, geometry: geometryRevision },\n      })),\n      AsyncResult.mapError(\n        sideEffect(error => {\n          monitor.close(error)\n          this.#logger.error(\n            'Unexpected error when calling RemoteDocument.getBoundingRectForRanges()',\n            error,\n          )\n        }),\n      ),\n    )\n  }\n\n  [Symbol.dispose](): void {\n    this.#disposables.dispose()\n  }\n}\n","import type { RemoteDocument } from '@grammarly/feature-connector'\nimport { DefaultTextDocument, type TextDocument } from './TextDocument'\nimport type { Monitoring } from '@grammarly/feature-monitoring'\n\n/**\n * A document session represents a scope for interacting with a document.\n * @public\n */\nexport interface DocumentSession {\n  /**\n   * The time when the session was started.\n   */\n  readonly startedAt: DOMHighResTimeStamp\n\n  /**\n   * The document being interacted with.\n   */\n  readonly lastFocusAt: DOMHighResTimeStamp\n\n  /**\n   * The document being interacted with.\n   */\n  readonly document: TextDocument\n}\n\nexport class DefaultDocumentSession implements DocumentSession, AsyncDisposable {\n  readonly startedAt = performance.now()\n  readonly remoteDocument: RemoteDocument\n  readonly document: TextDocument\n  readonly #disposables = new AsyncDisposableStack()\n\n  #lastFocusAt = this.startedAt\n\n  constructor(remoteDocument: RemoteDocument, monitoring: Monitoring) {\n    this.remoteDocument = remoteDocument\n    this.document = this.#disposables.use(new DefaultTextDocument(remoteDocument, monitoring))\n    this.#disposables.use(\n      this.document.hasFocus.subscribe(isFocused => {\n        if (isFocused) {\n          this.#lastFocusAt = performance.now()\n        }\n      }),\n    )\n  }\n\n  get lastFocusAt() {\n    return this.#lastFocusAt\n  }\n\n  use<T extends AsyncDisposable | Disposable>(disposable: T): T {\n    return this.#disposables.use(disposable)\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.#disposables.disposeAsync()\n  }\n}\n","import type { FeatureContext } from '@grammarly/feature'\nimport type {\n  ConnectorDocumentManager,\n  DocumentID,\n  RemoteDocument,\n} from '@grammarly/feature-connector'\nimport type { Monitoring } from '@grammarly/feature-monitoring'\nimport { createInjectionToken } from '@grammarly/util-dependency-container'\nimport { disposeAsync } from '@grammarly/util-disposable'\nimport { pipe } from '@grammarly/util-function'\nimport { logger } from '@grammarly/util-logging'\nimport { Rx, State, type SubscribableState } from '@grammarly/util-reactive'\nimport { AsyncResult, Result, ResultDisposable } from '@grammarly/util-result'\nimport { DefaultDocumentSession, type DocumentSession } from './DocumentSession'\nimport type { TextDocument } from './TextDocument'\n\n/** @public */\nexport const TextDocumentToken = createInjectionToken<TextDocument>(Symbol('TextDocument'))\n\n/** @public */\nexport const DocumentSessionToken = createInjectionToken<DocumentSession>(Symbol('DocumentSession'))\n\n/**\n * A manager for document sessions.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface DocumentSessionManager {\n  readonly activeDocumentId: SubscribableState<DocumentID | null>\n}\n\n/**\n * Number of documents to keep in memory.\n */\nconst MAX_ACTIVE_DOCUMENT_COUNT = 100 // This is set to a high number to avoid disposing documents as we depend on Llama to dispose them.\n\n/**\n * A manager for document sessions.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class DocumentSessionManager implements DocumentSessionManager, AsyncDisposable {\n  readonly #disposables = new AsyncDisposableStack()\n  readonly #sessions: DefaultDocumentSession[] = []\n  readonly #context: FeatureContext\n  readonly #monitoring: Monitoring\n  readonly #activeDocumentId = new State<DocumentID | null>(null)\n  readonly #logger = logger.createLogger('DocumentSessionManager')\n\n  readonly activeDocumentId: SubscribableState<DocumentID | null> = this.#activeDocumentId\n\n  constructor(\n    context: FeatureContext,\n    connectorDocumentManager: ConnectorDocumentManager,\n    monitoring: Monitoring,\n  ) {\n    this.#context = context\n    this.#monitoring = monitoring\n    this.#disposables.use(\n      connectorDocumentManager.onDocumentDidCreate.subscribe(document => {\n        this.#disposables.use(\n          pipe(\n            Rx.fromSubscribableState(document.hasFocus),\n            Rx.subscribe(focused => {\n              if (focused) {\n                this.#activeDocumentId.setValue(document.id)\n                if (!this.#getAndPromoteSession(document)) {\n                  void this.#createAndPromoteSession(document)\n                }\n              } else {\n                this.#activeDocumentId.setValue(null)\n              }\n            }),\n          ),\n        )\n      }),\n    )\n    this.#disposables.use(\n      connectorDocumentManager.onDocumentWillDestroy.subscribe(document => {\n        const session = this.#getSession(document)\n        if (session) this.#dropSession(session, 'document will destroy')\n      }),\n    )\n  }\n\n  /**\n   * Moves the session to the start of the session list.\n   * @param session - session to promote\n   */\n  #promoteSession(session: DefaultDocumentSession): void {\n    const index = this.#sessions.indexOf(session)\n    if (index === -1) {\n      this.#sessions.push(session)\n    } else {\n      this.#sessions.splice(index, 1)\n      this.#sessions.push(session)\n    }\n\n    if (this.#sessions.length > MAX_ACTIVE_DOCUMENT_COUNT) {\n      const session = this.#sessions.shift()\n      if (session !== undefined) {\n        this.#dropSession(session, 'session list is overflown')\n      }\n    }\n  }\n\n  /**\n   * Removes the session from the session list. Also disposes the session.\n   */\n  #dropSession(session: DefaultDocumentSession, reason: string): void {\n    const index = this.#sessions.indexOf(session)\n    if (index !== -1) {\n      this.#sessions.splice(index, 1)\n      this.#logger.verbose(\n        { context: session.remoteDocument.id },\n        `Disposing session for document because ${reason}.`,\n      )\n    }\n\n    void disposeAsync(session)\n  }\n\n  /**\n   * Returns the session for the document if it exists. Also promotes the session to the start of the session list.\n   */\n  #getAndPromoteSession(document: RemoteDocument) {\n    const session = this.#getSession(document)\n    if (session) this.#promoteSession(session)\n    return session\n  }\n\n  /**\n   * Returns the session for the document if it exists.\n   */\n  #getSession(document: RemoteDocument) {\n    return this.#sessions.find(session => session.remoteDocument.id === document.id) ?? null\n  }\n\n  /**\n   * Creates an execution scope for the document and promotes the session to the active list.\n   * @param document - document to create a session for\n   */\n  async #createAndPromoteSession(document: RemoteDocument): Promise<void> {\n    using createMonitor = this.#monitoring.duration('create_session')\n    await using disposable = new AsyncDisposableStack()\n    const session = new DefaultDocumentSession(document, this.#monitoring)\n    session.use(document)\n    this.#logger.verbose({ context: session.remoteDocument.id }, 'Create a session for document.')\n    this.#promoteSession(session)\n\n    disposable.defer(() => this.#dropSession(session, 'session is disposed'))\n\n    await pipe(\n      this.#context.createExecutionScope('document-session', session),\n      ResultDisposable.use(disposable),\n      Result.flatMap(scope =>\n        pipe(\n          ResultDisposable.all([\n            scope.register({\n              token: TextDocumentToken,\n              useValue: session.document,\n            }),\n            scope.register({\n              token: DocumentSessionToken,\n              useValue: session,\n            }),\n          ]),\n          ResultDisposable.use(disposable),\n          Result.map(() => scope),\n        ),\n      ),\n      AsyncResult.fromResult,\n      AsyncResult.flatMap(scope => scope.start()),\n      AsyncResult.match({\n        success: () => {\n          session.use(disposable.move())\n        },\n        failure: error => {\n          createMonitor.close(error)\n          this.#logger.error('Failed to create a session due to:', error, {\n            context: session.remoteDocument.id,\n          })\n        },\n      }),\n    )\n  }\n\n  async [Symbol.asyncDispose]() {\n    return this.#disposables.disposeAsync()\n  }\n}\n","import type { FeatureContext } from '@grammarly/feature'\nimport { createInjectionToken } from '@grammarly/util-dependency-container'\n\nexport const FeatureContextToken = createInjectionToken<FeatureContext>(Symbol('FeatureContext'))\n","/**\n * Defines an execution scope (\"documentSession\") which gets initiated when\n * a document is focused in the connector.\n *\n * @packageDocumentation\n */\n\nimport type {\n  Activate,\n  ExecutionScopeDefinition,\n  Feature,\n  FeatureContext,\n} from '@grammarly/feature'\nimport { createInjectionToken, defineFactory, Lifetime } from '@grammarly/util-dependency-container'\nimport { createDisposable } from '@grammarly/util-disposable'\nimport { constVoid, pipe } from '@grammarly/util-function'\nimport { logger } from '@grammarly/util-logging'\nimport { AsyncResult, Result, ResultDisposable } from '@grammarly/util-result'\nimport { type DocumentSession } from './DocumentSession'\nimport { DocumentSessionManager } from './DocumentSessionManager'\nimport { FeatureContextToken } from './dependencies'\n\nexport {\n  DocumentSessionToken,\n  TextDocumentToken,\n  type DocumentSessionManager,\n} from './DocumentSessionManager'\n\nexport type {\n  DocumentID,\n  ExtendedTextDocumentGeometryInfo,\n  GetBoundingRectsResponse,\n  GetRectsResponse,\n  TextDocument,\n  TextDocumentGeometryInfo,\n  TextDocumentGeometryWillChangeEvent,\n} from './TextDocument'\n\nimport type {} from '@grammarly/feature-performance-hud'\n\n/** @public */\nexport const DocumentSessionManagerToken = createInjectionToken<DocumentSessionManager>(\n  Symbol('DocumentSessionManager'),\n)\n\n/** @public */\nexport const activate: Activate = context =>\n  ResultDisposable.all([\n    pipe(\n      Result.all([\n        context.getFeature('connector'),\n        context.getFeature('monitoring'),\n        context.getExecutionScope('global'),\n      ] as const),\n      Result.flatMap(([connectorFeature, monitoringFeature, globalScope]) =>\n        ResultDisposable.all([\n          ...registerDependencies(context, globalScope, connectorFeature, monitoringFeature),\n          Result.success(\n            globalScope.onStart(async execution =>\n              // Create the document session manager when the global scope starts\n              // so that it can listen to document focus events.\n              execution.resolve(DocumentSessionManagerToken),\n            ),\n          ),\n        ]),\n      ),\n    ),\n    injectActiveDocIdIntoHUD(context),\n  ])\n\nfunction registerDependencies(\n  context: FeatureContext,\n  scope: ExecutionScopeDefinition<'global'>,\n  connectorFeature: Feature<'connector'>,\n  monitoringFeature: Feature<'monitoring'>,\n): ResultDisposable[] {\n  return [\n    scope.register({ token: FeatureContextToken, useValue: context }),\n    scope.register(\n      {\n        token: DocumentSessionManagerToken,\n        useFactory: defineFactory(DocumentSessionManager, [\n          FeatureContextToken,\n          connectorFeature.provides.ConnectorDocumentManager,\n          monitoringFeature.provides.Monitoring,\n        ]),\n      },\n      { lifetime: Lifetime.Singleton },\n    ),\n  ]\n}\n\nfunction injectActiveDocIdIntoHUD(context: FeatureContext): ResultDisposable {\n  return pipe(\n    context.getExecutionScope('global'),\n    Result.map(scope =>\n      scope.onStart(execution =>\n        // We log and ignore all errors from this pipe at the bottom\n        // so that we don't interfere with global scope startup since the HUD\n        // is a dev-only feature.\n        pipe(\n          context.getFeature('performance-hud'),\n          Result.flatMap(performanceHUDFeature =>\n            Result.all([\n              execution.resolve(performanceHUDFeature.provides.HUD),\n              execution.resolve(DocumentSessionManagerToken),\n            ] as const),\n          ),\n          Result.map(([hud, documentSessionManager]) =>\n            documentSessionManager.activeDocumentId.subscribe(activeDocumentId =>\n              hud.setActiveDocument(activeDocumentId),\n            ),\n          ),\n          Result.flatMapError(error => {\n            logger.error('Unexpected error using HUD in feature-document-session', error)\n            // We do not return HUD errors since it's a dev-only UI.\n            return Result.success(createDisposable(constVoid))\n          }),\n          AsyncResult.fromResult,\n        ),\n      ),\n    ),\n  )\n}\n\n// #region Augmentations\nexport type { DocumentSession } from './DocumentSession'\ndeclare module '@grammarly/feature' {\n  interface ExecutionScopeRegistry {\n    /**\n     * A document session represents an execution scope for\n     * interacting with a document, such as reading or writing\n     * its content, listening to changes as user types, etc.\n     *\n     * @public\n     *\n     * @example\n     * ```ts\n     * const result = context.getExecutionScope('documentSession')\n     * if (result.ok) {\n     *  const scope = result.value\n     *  scope.register({\n     *    // ... provider\n     *  })\n     *  scope.onStart(() => {\n     *    /// do something\n     *  })\n     * }\n     * ```\n     */\n    readonly 'document-session': DocumentSession\n  }\n}\n\n// #endregion\n"],"names":["_logger","_disposables","_text","_selection","_sampler","_windowFrameMoving","_windowFrameResizing","_documentFrameScrolling","_geometry","_geometryWillChange","_hasFocus","_onTextDidChange","_history","_monitoring","_counters","_document","_DefaultTextDocument_instances","purgeHistory_fn","getCountGroup_fn","DefaultTextDocument","document","monitoring","__privateAdd","State","TextRevision.initial","Delta","RandomUserSampler","Emitter","__privateSet","logger","onDidInit","timeoutWith","pipe","AsyncResult.map","text","__privateGet","refCounted","AutomaticRefCounted","AsyncResult.mapError","sideEffect","error","Result.success","Rx","textChange","previous","next","__privateMethod","ranges","geometryWillChange","geometryDidChange","reasons","focused","state","geometryDidChangeAfterWillChangeTimeout","timeoutMs","value","geometryRevision","GeometryRevision.initial","retryGetGeometryOnFailure","retryCount","GeometryRevision.create","_","index","_stack","monitor","__using","_error","_hasError","_promise","__callDispose","Result.match","geometry","_a","textRevision","rects","count","_lastFocusAt","DefaultDocumentSession","remoteDocument","__publicField","isFocused","disposable","_sessions","_context","_activeDocumentId","_DocumentSessionManager_instances","promoteSession_fn","dropSession_fn","getAndPromoteSession_fn","getSession_fn","createAndPromoteSession_fn","TextDocumentToken","createInjectionToken","DocumentSessionToken","MAX_ACTIVE_DOCUMENT_COUNT","DocumentSessionManager","context","connectorDocumentManager","session","reason","disposeAsync","createMonitor","ResultDisposable","Result.flatMap","scope","Result.map","AsyncResult.fromResult","AsyncResult.flatMap","AsyncResult.match","FeatureContextToken","DocumentSessionManagerToken","activate","Result.all","connectorFeature","monitoringFeature","globalScope","registerDependencies","execution","injectActiveDocIdIntoHUD","defineFactory","Lifetime","performanceHUDFeature","hud","documentSessionManager","activeDocumentId","Result.flatMapError","createDisposable","constVoid"],"mappings":"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"}